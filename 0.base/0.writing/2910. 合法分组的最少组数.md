---
title: 2910. 合法分组的最少组数
time: 2023-10-28
tags:
  - 题解
  - 贪心
  - 枚举
cssclasses:
  - 力扣题解
---
# [2910. 合法分组的最少组数](https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/)
## 题目详情
给你一个长度为 `n` 下标从 **0** 开始的整数数组 `nums` 。

我们想将下标进行分组，使得 `[0, n - 1]` 内所有下标 `i` 都 **恰好** 被分到其中一组。

如果以下条件成立，我们说这个分组方案是合法的：

- 对于每个组 `g` ，同一组内所有下标在 `nums` 中对应的数值都相等。
- 对于任意两个组 `g1` 和 `g2` ，两个组中 **下标数量** 的 **差值不超过** `1` 。

请你返回一个整数，表示得到一个合法分组方案的 **最少** 组数。

**示例 1：**

>**输入：** nums = `[3,2,3,2,3]`
>**输出：** 2
>**解释：** 一个得到 2 个分组的方案如下，中括号内的数字都是下标：
>组 1 -> `[0,2,4]`
>组 2 -> `[1,3]`
>所有下标都只属于一个组。
>组 1 中，`nums[0] == nums[2] == nums[4] `，所有下标对应的数值都相等。
>组 2 中，`nums[1] == nums[3]` ，所有下标对应的数值都相等。
>组 1 中下标数目为 3 ，组 2 中下标数目为 2 。
>两者之差不超过 1 。
>无法得到一个小于 2 组的答案，因为如果只有 1 组，组内所有下标对应的数值都要相等。
>所以答案为 2 。

**示例 2：**

>**输入：** `nums = [10,10,10,3,1,1]`
>**输出：** 4
>**解释：** 一个得到 2 个分组的方案如下，中括号内的数字都是下标：
>组 1 -> `[0]`
>组 2 -> `[1,2]`
>组 3 -> `[3]`
>组 4 -> `[4,5]`
>分组方案满足题目要求的两个条件。
>无法得到一个小于 4 组的答案。
>所以答案为 4 。

**提示：**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
---
## 题目分析

题目给出的是一个有重复元素出现的整型数组`nums`
而我们要做的就是对`nums`中的元素进行分组，分组满足以下条件：
1. **每组中的元素大小都是相同的**
2. **任意两组的大小相差都不能超过1**
然后再求出所分出来的组的最小数量

题目的意思还是相对直白，可以发现条件1是相对容易满足，而真正难处理的部分是在于如何满足条件2

---
## 解题思路

我们首先能想到的是，先不管每组的大小，只管先把它们都分了再说，也就是优先满足条件1
于是剩下的就是要考虑如何将已经分好的组再次细分达成条件2了，于是我们得到了一个新的分组情况，也就是`count`数组或者HashMap

最开始我想到的是直接找到最大的`count[i]`，然后直接将其均分，然后再将其他`count[i]`都按照这个大小来分，因为从直观上来讲这样的分组数量是最小的。
后来仔细研究发现，如果都按照`count[i]`均分后的大小来分的话，很可能会出现**其他`count[i]`在被分割后，**最后会剩下一点点元素，无法构成大小相差只为1的组**

这个时候就想到了**枚举**，因为我们完全无法直接确定每组应该所分元素个数`size`为多少，所以只能采用枚举的方式遍历每一种可能的情况
这里我们可以发现，**size的范围为`[1,min(count[i])]`**，size越大，组数越小，如果在`min(count[i])`就能完成分组，自然是再好不过了，因此从`min(count[i])`开始枚举

>看题解的评论中有人提到了二分查找，但是我觉得**这个没法用二分查找来确定**，因为使用某个size来计算，我们优先判断的是当前size能否完成满足两个条件的分组，只存在两个状态：**能与不能**。假设在不考虑能与不能的前提下进行二分查找，很可能我们最终确定的size范围里的每一个size都是不能满足分组条件的

于是我们还剩下最后一个问题，也是最重要的一个问题，就是我们**要怎么样判断当前的size是能完成满足两个条件下的分组的呢**？

按照size来分组最怕什么，就怕最后会剩下一点元素，无法构成新的单独一组
例如将`count[i]=13按照`size=5`且能浮动到`size=5`来分:
- 13 = 5 + 5 + 3
- 13 = 6 + 6 + 1
就能发现，**会剩下一个3或者1无法单独成组，即使是size有1个大小的浮动也不行**
通过观察然后找规律能发现
- `count[i] / size >= count[i] % size`时就一定能完成分配
- 在按照size来分时，可以分得`count[i] / size`组，同时还剩下`count[i] % size`个元素
- 而剩下的元素数量又比已经分好的组数少，**那么不就说明可以把这些多余的元素直接按照`size+1`的标准分配给前面的分好的组吗？**
由此，判断当前`count[i]`对于当前`size`是否可分已经解决了

于是只要算出每个`count[i]`可分的组就结束了
但是这里要注意，不是直接加个`count[i] / size`组就好了，测试样例都过不了
因为会出现一种情况
- `count[i] = 3`，但是size = 1
- 直接除以size就会发现会分3组
- 但是别忘了我们实际上还能给size加一个1来进行浮动
- 最少的分组应该是 3 = 2 + 1，也就是分为两组
于是改为加上`(count[i] + size) / (size + 1)`，这里边再加一个size是怕算出来直接为0了
---
## 对应代码

```java
/**  
 *  执行耗时:39 ms,击败了100.00% 的Java用户  
 *  内存消耗:58.8 MB,击败了100.00% 的Java用户  
 */  
class Solution {  
    public int minGroupsForValidAssignment(int[] nums) {  
        Map<Integer, Integer> count = new HashMap<>();  
        for (int num : nums) {  
            count.merge(num, 1, Integer::sum);  
        }  
        // 每组的大小初始化为数组中出现次数最少的那个数的出现次数，照这个分能分到组数最少  
        int size = Integer.MAX_VALUE;  
        for (Integer value : count.values()) {  
            size = Math.min(size, value);  
        }  
  
        // 枚举size的每一种情况，直到达成最小条件为止  
        while (size >= 0) {  
            int res = 0;  
            // 判断当前value是否可以按照size来分  
            for (Integer value : count.values()) {  
                // 核心判断条件是看，value对size取模后的结果能否全部放到已经分好的组中  
                if (value / size < value % size) {  
                    res = 0;  
                    break;  
                }  
                // 如果能放下，那就按照k+1的情况下分组，毕竟差值能为1  
                res += (value + size) / (size + 1);  
                // 不直接除以size是因为[10,10,10],size=1  
                // 因为只要差值不超过1都行，那我可以先把两个10分到一组  
                // 于是可以先加一个size再除以size+1,加一个size是怕算出来直接为0了  
            }  
            if (res > 0) return res;  
            size--;  
        }  
        return 0;  
    }  
}
```
### 复杂度分析
时间复杂度：
- 前面构建map时间复杂，O(nums.length)
- 查找map中最小值，O(count.length)
- 枚举size，O(size * count.length)
由于 size * count.length < nums.length
所以最终时间复杂度为O(n)

---
## 最后

题目最主要的难点在于如何判断某一个size是否能能满足对应的分组条件，以及其对应组数的计算

