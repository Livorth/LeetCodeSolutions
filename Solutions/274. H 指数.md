---
title: 274. H 指数
time: 2023-10-29
tags:
  - 题解
  - 数组
  - 排序
  - 计数排序
cssclasses:
  - 力扣题解
---
# [274. H 指数](https://leetcode.cn/problems/h-index/)
## 题目详情

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且每篇论文 **至少** 被引用 `h` 次。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

**示例 1：**

>**输入：**`citations = [3,0,6,1,5]`
>**输出：** 3 
>**解释：** 
>给定数组表示研究者总共有 `5` 篇论文，每篇论文相应的被引用了 `3, 0, 6, 1, 5` 次。
>由于研究者有 `3` 篇论文每篇 **至少** 被引用了 `3` 次，其余两篇论文每篇被引用 **不多于** `3` 次，所以她的 _h_ 指数是 `3`。

**示例 2：**

>**输入：** citations = [1,3,1]
>**输出：** 1

**提示：**
- `n == citations.length`
- `1 <= n <= 5000`
- `0 <= citations[i] <= 1000`

Related Topics
- 数组
- 计数排序
- 排序


---
## 题目分析

首先要理解什么是**H指数**

> 在发布的全部论文中，总共有 h 篇论文分别被引用了至少 h 次
> `[0,0,2] : 1`  -> 其中有**1篇**被引用了至少**1次**（实际上是两次）

也就是说不管你被引用的次数再怎么多，主要的影响因素还是有多少篇能达到这么多
所以回过头来，**我们需要做的是统计出被引用次数为大于等于h的论文有多少篇**

---
## 解题思路

### 思路1：sort排序

首先应该就能想到排序，当数据成为有序数组之后，我们就可以通过遍历找到最合适的位置    

**例如：**
>` [0,1,3,5,6] -> [6,5,3,1,0]`
> 首先能发现有**1篇**能满足引用次数超过**6次**引用：有**1篇**被引用了至少**1次**
> 然后有**2篇**能满足引用次数超过**5次**引用：有**2篇**被引用了至少**2次**
> 有**3篇**能满足引用次数超过**3次**引用：有**3篇**被引用了至少**3次**
> 满足条件且为最大的h值

#### 对应代码
```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        // 从大到小遍历
        for (int i = 0; i < citations.length; i ++) {
            int h = citations.length - i;
            if (citations[i] >= h)
                return h;
        }
        return 0;
    }
}
```

时间复杂度：因为有一个排序，所以时间复杂度为O(nlogn)

### 思路2：计数排序

其实上还是排序，只是换成了O(n)的排序而已，其本质上还是一样的
其中简化的一点：
> H 指数不可能大于总的论文发表数
> 所以对于引用次数超过论文发表数的情况，我们可以将其按照总的论文发表数来计算即可

#### 对应代码
```java
/**  
 * 执行耗时:0 ms,击败了100.00% 的Java用户  
 * 内存消耗:39.4 MB,击败了30.14% 的Java用户  
 */  
public class Solution {  
    public int hIndex(int[] citations) {  
        int len = citations.length;  
        // 计数，用数组也行，用map也行  
        int[] count = new int[len + 1];  
        for (int i = 0; i < len; i++) {  
            // 当引用次数大于n时，统一算做n  
            // 因为h指数最多只能到全部的论文  
            if (citations[i] >= len) {  
                count[len]++;  
            } else {  
                count[citations[i]]++;  
            }  
        }  
        int sum = 0;  
        // 从后往前遍历  
        for (int i = len; i >= 0; i--) {  
            // sum为大于或等于当前引用次数 i 的总论文数  
            sum += count[i];  
            if (sum >= i) {  
                return i;  
            }  
        }  
        return 0;  
    }  
}
```
时间复杂度：现在只剩下两个长度为len的循环了，所以时间复杂度为O(nlogn)

---
## 最后

上一次做这个题还是在21年7月，现在还会做，说明题目还是很简单的

