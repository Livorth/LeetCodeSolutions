# [2049. 统计最高分的节点数目](https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/)

给你一棵根节点为 `0` 的 **二叉树** ，它总共有 `n` 个节点，节点编号为 `0` 到 `n - 1` 。同时给你一个下标从 `0` 开始的整数数组 `parents `表示这棵树，其中 `parents[i]` 是节点` i` 的父节点。由于节点 `0` 是根，所以 `parents[0] == -1` 。

一个子树的 **大小** 为这个子树内节点的数目。每个节点都有一个与之关联的 **分数** 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 **删除** ，剩余部分是若干个 **非空** 子树，这个节点的 **分数** 为所有这些子树 **大小的乘积** 。

请你返回有 **最高得分** 节点的 **数目** 。

**示例 1:**

![example-1](https://pic.livorth.cn/img/example-1.png)

> 输入：parents = [-1,2,0,2,0]
> 输出：3
> 解释：
>
> - 节点 0 的分数为：3 * 1 = 3
> - 节点 1 的分数为：4 = 4
> - 节点 2 的分数为：1 * 1 * 2 = 2
> - 节点 3 的分数为：4 = 4
> - 节点 4 的分数为：4 = 4
>
> 最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。

**示例 2：**

![example-2](https://pic.livorth.cn/img/example-2.png)

> 输入：parents = [-1,2,0]
> 输出：2
> 解释：
>
> - 节点 0 的分数为：2 = 2
> - 节点 1 的分数为：2 = 2
> - 节点 2 的分数为：1 * 1 = 1
> 	最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。

**提示：**

- `n == parents.length`
- `2 <= n <= 10^5`
- `parents[0] == -1`
- 对于` i != 0` ，有 `0 <= parents[i] <= n - 1`
- `parents `表示一棵二叉树。

---

## 题目分析

不知道是我阅读能力不行还是这个题目翻译的不行，导致我题目都看了好久

简单来说就是题目将给出你一个树，这个树是用数组**存储的每个节点的父节点**，而**根结点的父节点记为-1**

我们的目标是，将某个节点以及他连接的边进行删除，形成新的几棵树

> 比如示例1中
>
> - 删除了节点0时，余下2棵子树，分别有3个节点与4个节点
> - 删除了节点1时，余下1棵子树，有4个节点
> - 删除了节点2时，余下3棵子树，分别有1个、1个与2个节点
> - ...

对每个节点来说他们都有一个分数，这个分数是**由余下子树的节点数乘到一起得到的结果**

而我们要求的是**有着最大分数的节点数量**

---

## 解题思路

由于题目给的是二叉树，所以在删除一个节点只后，最多余下3个树

- 被删除节点的左子树
- 被删除节点的右子树
- 包含被删除节点父节点的树

这里前两个部分很好求，直接**使用DFS遍历每个节点统计数量**就好了~~（快进到用记忆化）~~

第三个说不好求其实也好求，**因为我直接拿总节点数减去前两个部分的数量不就完了**

只要将这三个树的节点数量求出来，就能直接计算出这个节点的分数，进而进行统计

**注意：**

- 树的传入方式是使用数组记录每个节点的父节点，我们需要将其转换为存储子节点
- 如果是二叉树，可以使用两个数组进存储
- 如果是多叉数，可以使用链表进行存储

---

## 对应代码

```java
class Solution {
    // 记录每个节点的左右子节点
    private int[] L, R;
    private long maxProduct;
    private int maxCount, n;

    public int countHighestScoreNodes(int[] parents) {
        n = parents.length;
        // 二叉树可以使用两个数组来存储，如果是多叉数可以用List来存储
        L = new int[n];
        R = new int[n];
        // 初始化
        for (int i = 0; i < n; i++) {
            L[i] = R[i] = -1;
        }
        for (int node = 1; node < n; node++) {
            // 其实谁是左节点谁是右节点根本无所谓
            if (L[parents[node]] == -1) {
                L[parents[node]] = node;
            }
            else {
                R[parents[node]] = node;
            }
        }
        dp(0);
        return maxCount;
    }

    private int dp(int node) {
        // 空节点
        if (node == -1) {
            return 0;
        }
        // 左右子树的节点数量
        int l = dp(L[node]);
        int r = dp(R[node]);
        // 左子树 * 右子树 * 父节点所在的数，但是如果没有树的情况返回的结果就是0，那就转换为1，不影响
        long product = (long) Math.max(l, 1) * Math.max(r, 1) * Math.max(n - l - r - 1, 1);
        
        // 更新结果
        if (maxProduct < product) {
            maxProduct= product;
            maxCount = 1;
        } 
        else if (maxProduct == product) {
            maxCount++;
        }
        return l + r + 1;
    }
}
```

![image-20220311100002073](https://pic.livorth.cn/img/image-20220311100002073.png)

---

## 最后

现在阻碍我刷题的主要是阅读理解（bushi）

