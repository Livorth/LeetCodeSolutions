# [636.函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/)

有一个 **单线程** CPU 正在运行一个含有 `n` 道函数的程序。每道函数都有一个位于 `0` 和 `n-1` 之间的唯一标识符。

函数调用 **存储在一个 [调用栈](https://baike.baidu.com/item/调用栈/22718047?fr=aladdin) 上** ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 **当前正在执行的函数** 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。

给你一个由日志组成的列表 `logs` ，其中 `logs[i]` 表示第 `i` 条日志消息，该消息是一个按 `"{function_id}:{"start" | "end"}:{timestamp}"` 进行格式化的字符串。例如，`"0:start:3"` 意味着标识符为 `0` 的函数调用在时间戳 `3` 的 **起始开始执行** ；而 `"1:end:2"` 意味着标识符为 `1` 的函数调用在时间戳 `2` 的 **末尾结束执行**。注意，函数可以 **调用多次，可能存在递归调用** 。

函数的 **独占时间** 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 `2` 单位时间，另一次调用执行 `1` 单位时间，那么该函数的 **独占时间** 为 `2 + 1 = 3` 。

以数组形式返回每个函数的 **独占时间** ，其中第 `i` 个下标对应的值表示标识符 `i` 的函数的独占时间。

**示例 1：**

![img](https://pic.livorth.cn/img/diag1b.png)

```
输入：n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
输出：[3,4]
解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 
函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 
函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 
所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 
```

**示例 2：**

```
输入：n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
输出：[8]
解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
函数 0（初始调用）恢复执行，并立刻再次调用它自身。
函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。
函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。
所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。
```

**示例 3：**

```
输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
输出：[7,1]
解释：
函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
函数 0（初始调用）恢复执行，并立刻调用函数 1 。
函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。
函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。
所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 
```

**示例 4：**

```
输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]
输出：[8,1]
```

**示例 5：**

```
输入：n = 1, logs = ["0:start:0","0:end:0"]
输出：[1]
```



**提示：**

- `1 <= n <= 100`
- `1 <= logs.length <= 500`
- `0 <= function_id < n`
- `0 <= timestamp <= 109`
- 两个开始事件不会在同一时间戳发生
- 两个结束事件不会在同一时间戳发生
- 每道函数都有一个对应 `"start"` 日志的 `"end"` 日志

**Related Topics**

- 栈

- 数组

---

## 题目分析

题目的意思其实不难理解，但是题目的描述有点复杂

简单来说就是需要在**单线程**的cpu上运行**n个线程**

其中**线程不一定是连续执行的**

所以我们要记录的是**每个线程的执行了多少个单位时间**

题目给出的日志列表是字符串列表，通过 **":"** 分隔开

- 第一个位置为 int 数字，表示线程的编号
- 第二个位置表示当前线程的状态，**只有开始或者结束**
- 第三个位置也是 int 数字，表示当前线程执行改变状态的所在的单位时间

---

## 解题思路

在没看题目的时候，直接看样例，就发现了start和end，就开始猜测是否和栈有关

在看完题目后，更确定是用栈来模拟CPU的运行

- 当状态为 **`start`** 即为线程开始执行，入栈
- 当状态为 **`end`** 即为线程结束执行，出栈
- **在栈顶的线程，即为当前在执行的线程**

其中如果一个新线程开始执行，则之前的线程需要停止

而栈顶的线程结束执行，则下一层的线程会自动执行

在确定使用栈来模拟线程执行的状态后，**现在的问题就来到了如何记录时间**

其实这个也好解决，因为执行的时间是线性的

**所以可以直接使用一个变量来存储上一次操作所在的时间单位**

在每次线程的操作变更后，都对线程的时长进行更新

---

## 对应代码

```java
class Solution {
    public int[] exclusiveTime(int n, List<String> logs) {
        // 使用数组存储每个线程的消耗时间
        int[] ans = new int[n];
        // 使用双端队列模拟栈
        Deque<Integer> stack = new ArrayDeque<>();
        // 记录上一个线程操作的位置
        int lastPos = 0;
        for (String log : logs) {
            String[] ss = log.split(":");
            // 线程的编号
            int index = Integer.parseInt(ss[0]);
            // 当前线程操作的位置
            int cur = Integer.parseInt(ss[2]);


            if (ss[1].equals("start")) {
                // 栈不为空，则说明上一个线程中断，需要更新时长
                if (!stack.isEmpty()){
                    ans[stack.peekLast()] += cur - lastPos;
                }
                // 新线程入栈
                stack.addLast(index);
                lastPos = cur;
            }
            else {
                // 线程结束，出栈，并更新时长
                int idx = stack.pollLast();
                ans[idx] += cur - lastPos + 1;
                lastPos = cur + 1;
            }
        }
        return ans;
    }
}
```

---

## 最后

看懂题目后很快就能理清楚思路，通过分析所以代码也不难写，所以：

代码参考的[宫水三叶老师](https://leetcode.cn/u/ac_oier/)的题解：[【宫水三叶】简单栈运用模拟题]([[宫水三叶]简单栈运用模拟题 - 函数的独占时间 - 力扣（LeetCode）](https://leetcode.cn/problems/exclusive-time-of-functions/solution/by-ac_oier-z3ed/))