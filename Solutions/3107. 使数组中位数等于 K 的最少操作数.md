---
title: 3107. 使数组中位数等于 K 的最少操作数
time: 2024-04-11
tags:
  - 题解
  - 排序
cssclasses:
  - 力扣题解
rating:
---
# [3107. 使数组中位数等于 K 的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-median-of-array-equal-to-k/)
## 题目详情

给你一个整数数组 `nums` 和一个 **非负** 整数 `k` 。一次操作中，你可以选择任一元素 加 `1` 或者减 `1` 。

请你返回将 `nums` **中位数** 变为 `k` 所需要的 **最少** 操作次数。

一个数组的中位数指的是数组按非递减顺序排序后最中间的元素。如果数组长度为偶数，我们选择中间两个数的较大值为中位数。

**示例 1：**

> **输入：** nums = [2,5,6,8,5], k = 4
**输出：** 2
**解释：** 我们将 `nums[1]` 和 `nums[4]` 减 `1` 得到 `[2, 4, 6, 8, 4]` 。现在数组的中位数等于 `k` 。

**示例 2：**

> **输入：** nums = [2,5,6,8,5], k = 7
> **输出：** 3
> **解释：** 我们将 `nums[1]` 增加 1 两次，并且将 `nums[2]` 增加 1 一次，得到 `[2, 7, 7, 8, 5]` 。

**示例 3：**

> **输入：** nums = [1,2,3,4,5,6], k = 4
> **输出：** 0
> **解释：** 数组中位数已经等于 `k` 了。

**提示：**

- `1 <= nums.length <= 2 * 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= k <= 10^9`

Related Topics
- 贪心
- 数组
- 排序

---
## 题目分析

题目的需求很简单，单纯就是**让数组的中位数变成k**
然后求修改量最少的时候为多少

下面我们用 `nums = [2,5,6,8,5]` 来进行举例
> 首先就先进行排序，不然现在的中位数是谁都不知道
> `nums = [2,5,5,6,8]`，当前的中位数为`nums[2] = 5`
> 假设k = 4，也就是我们需要将nums的中位数转为4
> `[2,5,5,6,8]` - > `[2,5,4,6,8]`
> 很显然，这个时候4的左边还有一个5，也需要转为4
> `[2,5,4,6,8]` - > `[2,4,4,6,8]`
> 如果k=7也是同理

总结：也就是我们需要将中位数**左侧所有大于k的数和右侧所有小于k的数转为k**

---
## 解题思路

按照前面的分析，我们只需要进行两步即可算出结果
1. 排序
2. 判断nums[mid]与k之间的关系
		- nums[mid] > k ，则将左侧所有大于k的数全部转成k
		- nums[mid] > k ，则将右侧所有小于k的数全部转成k

---
## 对应代码

```java
/**
 * 执行耗时:31 ms,击败了99.74% 的Java用户
 * 内存消耗:61 MB,击败了76.67% 的Java用户
 */
class Solution {
	public long minOperationsToMakeMedianK(int[] nums, int k) {
		Arrays.sort(nums);
		int mid = nums.length / 2;
		long res = 0;
		// mid 左边的数全部都要≤k
		if (nums[mid] > k) {
			int t = mid;
			while (t >= 0 && nums[t] > k) {
				res += nums[t--] - k;
			}
		} else if (nums[mid] < k) {
			int t = mid;
			while (t < nums.length && nums[t] < k) {
				res += k - nums[t++];
			}
		}
		return res;
	}
}
```

### 复杂度分析

主要进行了两步操作
1. 排序，时间复杂度O(nlogn)
2. 计算结果，单边遍历O(n/2)
所以这个解法的时间复杂度是O(nlogn)

---
## 最后

没有注意到返回的是long，还错了一次
愈发觉得Python写算法还是更便捷一些


