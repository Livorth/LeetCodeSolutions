# [1994. 好子集的数目](https://leetcode-cn.com/problems/the-number-of-good-subsets/)

给你一个整数数组 `nums `。如果 `nums `的一个子集中，所有元素的乘积可以表示为一个或多个 **互不相同的质数** 的乘积，那么我们称它为 **好子集** 。

比方说，如果 `nums = [1, 2, 3, 4]` ：

- `[2, 3] `，`[1, 2, 3]` 和` [1, 3] `是 好 子集，乘积分别为` 6 = 2*3` ，`6 = 2*3` 和` 3 = 3` 。
- `[1, 4]` 和` [4]` 不是 好 子集，因为乘积分别为 `4 = 2*2 `和 `4 = 2*2` 。

请你返回 `nums `中不同的 **好** 子集的数目对 `10^9 + 7 `取余 的结果。

`nums `中的 **子集** 是通过删除 `nums `中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。

 

**示例 1：**

> 输入：nums = [1,2,3,4]
> 输出：6
> 解释：好子集为：
>
> - [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
> - [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
> - [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
> - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
> - [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
> - [3]：乘积为 3 ，可以表示为质数 3 的乘积。

**示例 2：**

> 输入：nums = [4,2,3,15]
> 输出：5
> 解释：好子集为：
>
> - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
> - [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
> - [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
> - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
> - [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。

**提示：**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 30`

---

## 题目分析

题目将给你一个整数集，**最大只能到30**，也就是数字的范围给定了

好子集就是在上述这个整数集中，选出部分数字组成一个子集，将这个子集里的每个整数全部乘起来之后得到一个数，这个数**只能是相互不同质数的乘积**，也就是**质因数里面不能有平方数**

既然不能有平方数，那么可以对子集进行一个初步的筛选：

- `4,8,9,12,16,18,20,24,25,27,28`：这些数包含平方因子，因此**一定不能在好子集中出现**。

然后有一个特殊的数字： **1**

- 不管是哪个好子集，我们添加**任意数量**的 **1** 都**不会有任何影响**

好了，接下来就可以**暴力枚举所有可能的合数组合**了（bushi）

- 但是事实上是可以这么解的，效率还是最高的（[官方题解](https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/hao-zi-ji-de-shu-mu-by-leetcode-solution-ky65/)的下面的评论区就有这种解法，有空可以看看）

---

## 解题思路

回归正题，还是考虑这个题目所考察我们的知识点在哪吧

这里我们从**不能重复出现的质数**出发，因为1至30中只有10个质数，而且在好子集的乘积结果数中**每个质数至多出现一次**

### 方法选择

这里就能想到**动态规划**，但是由于情况过多（可能出现复数个相同的质数）这里就将动态规划进化为**状态压缩动态规划**

> 简单讲下在这个题目里状态压缩：（想要深入了解建议看他人的博客）
>
> 这里我们有10个质数，我们可能选了其中某个，也可能没选
>
> 当我们使用**1表示选择了**，**0表示没选**
>
> 00 0000 0000 -> 表示一个都没选
>
> 00 0010 0010 -> 表示只选了`3`与`13`
>
> 也就是将我们对质数的选择情况转换为一个二进制数

**我们的好子集个数是由质数的选择情况决定的**，所以我们从**质数的出现情况**来做动态规划

### 变量指定

这里我们定义

- 变量 **num** 描述 原整数集 中**任意一个数**
- 变量 **maskForNum** 描述**num**中质数的**存在情况**

- 变量 **state** 描述每一种**质数的选择状态**，也就是我们在**maskForNum**的基础上进行的状态改变量
- 数组 **count[]** 统计 **num** 的重复情况
- 数组 **dp[maskForNum|state]** 表示为在**选择了num的前提下**再选择**state中标记的质数**之后的**好子集个数**，也就是**maskForNum**改变**state**之后的好子集个数

### 状态转移方程

**然后来思考状态转移方程要怎么列：**

> 状态转移方程肯定是从一个状态到另一个状态，那就与state息息相关
>
> **dp[state]** 则就是先状态**state**的时候好子集个数
>
> 如果我们要选**num**还要选**state**中标记的质数，那么新增的好子集个数就是**`count[num]*dp[state]`**

这样就能列出状态转移方程：

**`dp[maskForNum|state] += count[num]*dp[state]`**

接下来的问题就是如何对**dp[]**进行初始化

一般的默认的状态数量肯定都是0，但是有一个特殊的

- **`dp[0] = 1`**，**state**为0，通过对公式的反推得到这个初始化的状态

> 有一个小点，就是我在state里面选了某个质数，但是这个质数没在原数组里面怎么办？
>
> 这个很简单：dp[state] = 0，也就没影响了



### 代码逻辑

1. 进行变量定义以及 **dp[]**的初始化
2. 将**nums[]**中的每个数的出现情况统计到**count[]**
3. 从小到大遍历**nums[]**中的每个数
	1. 将有平方数质因数的**num**排除
	2. 将**num**的质数出现情况统计进 **maskForNum**
	3. 遍历每一种可能的**state**
		- 如果当前**state**中某一个质数在**maskForNum**已经存在了，就跳过
		- 套用**`dp[maskForNum|state] += count[num]*dp[state]`**进行动态规划

4. 统计**dp[]** 中所有好子集的总和，注意 **dp[0]** 不需要统计
5. 然后就是针对特殊数 **1**，**有多少个1，最后的结果就乘以2的多少次方**

---

## 对应代码

```java
class Solution {
    private final int mod=1000000007;
    public int numberOfGoodSubsets(int[] nums) {
        long res = 0;
        int[] prime = {2,3,5,7,11,13,17,19,23,29};
        // long 防止溢出
        long[] dp = new long[1024];
        // dp数组初始化
        dp[0] = 1;
        int[] count = new int[31];
        for(int num : nums) count[num]++;
        // 遍历nums中的每一个数，除了1
        for(int num = 2; num <= 30; ++num){
            // 当前数不存在，当前数带有平方数 跳过
            if(count[num] == 0 || num % 4 == 0||num % 9 == 0 || num % 25 == 0) continue;

            // 对10个质数做处理，如果当前数能被质数整除，则记录进maskForNum
            int maskForNum = 0;
            for(int i = 0; i < 10; ++i){
                if(num % prime[i] == 0) maskForNum |= ( 1 << i);
            }

            // 遍历每一种状态
            for(int state = 0; state < 1024; ++state){
                // maskForNum中已经存在了其中一个质数，跳过
                if((maskForNum & state) > 0) continue;
                //这里可能会溢出，所以dp数组类型为long
                // 更新当前状态的的好子集个数
                dp[maskForNum|state] = (dp[maskForNum|state] + count[num] * dp[state])%mod;
                // System.out.println( num + " --- " + state + " --- " + dp[state]);
            }
        }
        // dp[0]不算进去
        for(int i = 1; i < 1024; ++i) res = (res + dp[i]) % mod;
        // 有多少个1，最后的结果就乘以2的多少次方
        for(int i = 0; i < count[1]; ++i) res = (res * 2) % mod;
        return (int)res;
    }
}
```

![image-20220222131337828](http://pic.livorth.cn/img/image-20220222131337828.png)

---

## 结语

困难题多少还是有点难度的，cv自然简单，真要搞懂还得自己写题解

这里特别致谢[归鸿唱晚的1994. 好子集的数目](https://www.cnblogs.com/Frank-Hong/p/15335301.html)

我的思路与代码来自于这篇题解

