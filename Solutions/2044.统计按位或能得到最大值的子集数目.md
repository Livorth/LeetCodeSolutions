# [2044. 统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/)

给你一个整数数组 `nums` ，请你找出 `nums` 子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目** 。

如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 `a` 是数组 `b` 的一个 **子集** 。如果选中的元素下标位置不一样，则认为两个子集 **不同** 。

对数组 `a` 执行 **按位或** ，结果等于 `a[0] **OR** a[1] **OR** ... **OR** a[a.length - 1]`（下标从 **0** 开始）。

**示例 1：**

> 输入：nums = [3,1]
> 输出：2
> 解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：
>
> - [3]
> - [3,1]

**示例 2：**

> 输入：nums = [2,2,2]
> 输出：7
> 解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。

**示例 3：**

> 输入：nums = [3,2,1,5]
> 输出：6
> 解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：
>
> - [3,5]
> - [3,1,5]
> - [3,2,5]
> - [3,2,1,5]
> - [2,5]
> - [2,1,5]

**提示：**

- `1 <= nums.length <= 16`
- `1 <= nums[i] <= 10^5`

---

## 题目分析

我们需要找到所有子集， **按位或** 可能得到的 **最大值**

比如子集[3,5]可能 **按位或** 可以得到的 **最大值** 就是 **7** 

> 3 -> 011
>
> 5 -> 011
>
> 7 -> 111

然后只要再加入的数字小于7，那么 **按位或** 可以得到的 **最大值** 依然是 **7** ，例如

> - [3,5]
> - [3,1,5]
> - [3,2,5]
> - [3,2,1,5]

而我们要找的，就是有多少个这样的子集，**按位或** 可以得到的 **最大值** 是 **7**

**但其实对于这个最大值，其实只要将数组中所有的数组或一遍，得到的就是最大值**

**所以一开始最大值就是固定的**

---

## 解题思路

直接枚举每一种情况就不详细讲了，暴力是可以过的

这里主要讲**DFS**

### 选与不选

对于数组中的每一个元素来说，他们都有两种命运

当我们搜索到每一个元素时

- 我们可以选择将它**添加**进我们现有的**或运算集合**中
- 也可以**不添加**

这也是我们DFS的基础

直到搜索到最后一个元素时，比较现有的**或运算集合**与**最大值**之间的关系

- 相等就ans++
- 更小就排除

#### 对应代码

```java
class Solution {
    int ans = 0;
    public int countMaxOrSubsets(int[] nums) {
        int max = 0;
        for(int p : nums){
            max |= p;
        }
        dfs(nums, 0, 0, max);
        return ans;
    }
     public void dfs(int[] nums, int start, int all, int max){
        if (start == nums.length) {
            if(all == max){
                ans++;
            }
            return;
        }
        // 选或不选
        dfs(nums, start + 1, all | nums[start], max);
        dfs(nums, start + 1, all, max);
    }
}
```

![image-20220315130051443](https://pic.livorth.cn/img/image-20220315130051443.png)

---

### 优化DFS

当然我们也可以对DFS进行优化

1. 当我们搜索到某一个元素时，现有的**或运算集合**已经等于最大的情况了，这时候**不管后面没有搜到的元素到底怎么选**，最终的结果都会是等于最大值，那么**直接将ans加上后面可以有的情况数量**就好了
2. 并不一定纠结于单个元素的选与不选，**可以一次性不选多个**

#### 对应代码

```java
class Solution {
    int ans = 0;
    public int countMaxOrSubsets(int[] nums) {
        int max = 0;
        for(int p : nums){
            max |= p;
        }
        dfs(nums,0,0,max);
        return ans;
    }
    public void dfs(int[] nums,int start,int all,int max){
        // 直接将ans加上后面可以有的情况数量
        if(all == max){
            ans += 1 << (nums.length - start);
            return;
        }
        // 一次性不选多个
        for (int i = start;i < nums.length;i++){
            dfs(nums,i + 1,all | nums[i],max);
        }
    }
}
```

![image-20220315130940584](https://pic.livorth.cn/img/image-20220315130940584.png)

---

## 最后

如果是异或就会稍微麻烦点

我在看到题目之后我的脑子还闪过几个词，动态规划、状态压缩

但是也没必要想太复杂

