# [639. 解码方法 II](https://leetcode-cn.com/problems/decode-ways-ii/)

一条包含字母 `A-Z` 的消息通过以下的方式进行了编码：

> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26

要 **解码** 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，`"11106" `可以映射为：

- "AAJF" 对应分组 (1 1 10 6)
- "KJF" 对应分组 (11 10 6)

注意，像` (1 11 06) `这样的分组是无效的，因为` "06"` 不可以映射为` 'F'` ，因为` "6"` 与 `"06"` 不同。

除了 上面描述的数字字母映射方案，编码消息中可能包含` '*' `字符，可以表示从` '1' `到` '9' `的任一数字（不包括 '0'）。例如，编码字符串 `"1*" `可以表示` "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18"` 或 `"19" `中的任意一条消息。对 `"1*" `进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串` s` ，由数字和` '*' `字符组成，返回 **解码** 该字符串的方法 **数目** 。

由于答案数目可能非常大，返回对 `10^9 + 7 `**取余** 的结果。

**示例 1：**

> 输入：s =` "*"`
> 输出：9
> 解释：这一条编码消息可以表示 "1"、"2"、"3"、"4"、"5"、"6"、"7"、"8" 或 "9" 中的任意一条。
> 可以分别解码成字符串 "A"、"B"、"C"、"D"、"E"、"F"、"G"、"H" 和 "I" 。
> 因此，`"*"` 总共有 9 种解码方法。

**示例 2：**

> 输入：s = `"1*"`
> 输出：18
> 解释：这一条编码消息可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条。
> 每种消息都可以由 2 种方法解码（例如，"11" 可以解码成 "AA" 或 "K"）。
> 因此，`"1*"` 共有 9 * 2 = 18 种解码方法。

**示例 3：**

> 输入：s = `"2*"`
> 输出：15
> 解释：这一条编码消息可以表示 "21"、"22"、"23"、"24"、"25"、"26"、"27"、"28" 或 "29" 中的任意一条。
> "21"、"22"、"23"、"24"、"25" 和 "26" 由 2 种解码方法，但 "27"、"28" 和 "29" 仅有 1 种解码方法。
> 因此，`"2*"` 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。

**提示：**

- `1 <= s.length <= 10^5`
- s[i] 是 0 - 9 中的一位数字或字符` '*'`

---

## 题目分析

本题是[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)的进阶版本，相较于91题，本题添加了一个新的变量 `*`，其可以代表`[1,9]`

但是解题的思路还是差不多的，同样还是分情况讨论，然后进行dp，只是分的情况会要更多而已

推荐还是先做完91题再做当前题

---

## 解题思路

求的解码的总次数，那么还是使用动态规划

定义一个数组dp，其中`dp[i]`代表着字符串到其位置`i`时的解码方法总数

因为除了前9个字母，后面的字母都是需要用到2个字符才能构成的，那么主要是讨论，**是采用一个字符还是两个字符了**

那么存在以下多情况：

![image.png](https://pic.leetcode-cn.com/1632748161-FPlOqP-image.png)

根据上面所分出来的情况，那么同样可以给出所有的动态规划方程以及他们的限制条件

**但是情况太多了，详细的还是看代码或者去看官方题解吧，我懒得一一列举了**

同时注意到每次进行动态规划，**`dp[i]`只与`dp[i-1]`与`dp[i-2]`相关**，所以其实可以缩减为**3个变量进行存储**

**注意以下几点：**

- 特殊情况的**初始化**
	- 首位为0，无法解析
	- 首位为`*`，直接获得9种情况
	- 其他都为1
- 动归方程情况众多，不要遗漏
- 还有就是在每次更新dp后都要进行一个取模操作

---

## 对应代码

```java
class Solution {
    public int numDecodings(String s) {
        char[] chars = s.toCharArray();
        int n = chars.length;

        // 0只能在第二位
        if(chars[0] == '0'){
            return 0;
        }
        
        // 可以使用一个数组进行dp，但是每次进行动态规划只与前两次的数据相关，所以只使用两个变量进行存储，然后t作为中间变量
        long dp1 = 1, dp2, t;
        // 特殊情况的初始化
        if(chars[0] == '*'){
            dp2 = 9;
        }else{
            dp2 = 1;
        }

        for (int i = 1; i < n; i++) {
            // 记录前一位的情况和，后续需要赋值给dp1
            t = dp2;
            // 出现0，那么必须是两个位置的数字进行组合
            if(chars[i] == '0'){
                // * 也就是*0，可以是10，也可以是20，数量翻倍
                if(chars[i - 1] == '*'){
                    dp2 = dp1 * 2;
                    dp1 = t;
                }
                // 前一位是1或者2，可以组成10或者20，那么数量不变
                else if(chars[i - 1] == '2' || chars[i - 1] == '1'){
                    dp2 = dp1;
                    dp1 = t;
                }
                // 排除后的结果只能说明不能组成单个字母
                else{
                    return 0;
                }
            }
            // 这里是 *
            else if(chars[i] == '*'){
                // 单个的时候：[1,9]，两个的时候：组成 ** ，即[11,19]与[21,26]
                if(chars[i - 1] == '*'){
                    dp2 = dp2 * 9 + dp1 * 15;
                    dp1 = t;
                }
                // 当前这个 * 只能单走
                else if(chars[i - 1] == '0' || chars[i - 1] - '0' > 2){
                    dp2 = dp2 * 9;
                    dp1 = t;
                }
                // 组成 1*，9中情况
                else if(chars[i - 1] == '1'){
                    dp2 = dp2 * 9 + dp1 * 9;
                    dp1 = t;
                }
                // 剩下的就是组成 2*，6中情况
                else{
                    dp2 = dp2 * 9 + dp1 * 6;
                    dp1 = t;
                }
            }
            // 剩下的就是 [1,9]中任意的数字
            else{
                // 单走就是只能为1个，但是如果当前数为[1,6]，那么就既可以与1组合也可以和2组合
                if(chars[i - 1] == '*' && chars[i] - '0' < 7){
                    dp2 = dp2 + dp1 * 2;
                    dp1 = t;
                }
                // 前数为[7,9]，那么就只可以与1组合
                else if(chars[i - 1] == '*' || chars[i - 1] == '2' && chars[i] - '0' < 7 || chars[i-1] == '1'){
                    dp2 = dp2 + dp1;
                    dp1 = t;
                }
                // 剩下的就是只能单走的情况
                else{
                    dp2 = dp2;
                    dp1 = t;
                }
            }
            dp1 = dp1 % (1000000007);
            dp2 = dp2 % (1000000007);
        }
        return (int)dp2;
    }
}
```
![image.png](https://pic.leetcode-cn.com/1632746546-nYwqpz-image.png)

