# [764.最大加号标志](https://leetcode.cn/problems/largest-plus-sign/)

在一个 `n x n` 的矩阵 `grid` 中，除了在数组 `mines` 中给出的元素为 `0`，其他每个元素都为 `1`。`mines[i] = [xi, yi]`表示 `grid[xi][yi] == 0`

返回 `grid` *中包含 `1` 的最大的 **轴对齐** 加号标志的阶数* 。如果未找到加号标志，则返回 `0` 。

一个 `k` 阶由 *`1`* 组成的 **“轴对称”加号标志** 具有中心网格 `grid[r][c] == 1` ，以及4个从中心向上、向下、向左、向右延伸，长度为 `k-1`，由 `1` 组成的臂。注意，只有加号标志的所有网格要求为 `1` ，别的网格可能为 `0` 也可能为 `1` 。

**示例 1：**

![img](https://pic.livorth.cn/img/plus1-grid.jpg)

```
输入: n = 5, mines = [[4, 2]]
输出: 2
解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。
```

**示例 2：**

![img](https://pic.livorth.cn/img/plus2-grid.jpg)

```
输入: n = 1, mines = [[0, 0]]
输出: 0
解释: 没有加号标志，返回 0 。
```

**提示：**

- `1 <= n <= 500`
- `1 <= mines.length <= 5000`
- `0 <= xi, yi < n`
- 每一对 `(xi, yi)` 都 **不重复**

**Related Topics**

- 数组

- 动态规划

---

## 题目分析

题目要求的是矩阵中最大的"加号"阶数，所以首先要理解两个概念

1. 加号：中心是1，能分别向上下左右四个方向延伸，并且四支的长度都相等，当然四支也只能由1组成
2. 阶数：能往外延伸的个数，如果就单单只有中心一个1的时候阶数就是1，能往外延伸1个数的时候就是2，以此类推，下图分别是阶数为1,2,3的情况

![image-20221109103008193](https://pic.livorth.cn/img/image-20221109103008193.png)

---

## 解题思路

看到题目的时候，第一反应就是遍历每个点，然后同时沿着4个方向往外延伸，看了下n的大小，只有500

在时间复杂度为O(N^3)的情况下，数据量有125百万，可能可以过，但不是很推崇

> 看了题解与评论区，大伙说直接使用暴力(O(N^3))，java也是可以过的

其实可以将问题简化，不用直接就看4个方向的分支，**因为我们阶数只由四个分支中最小的那支决定**

**所以我们可以分别求出四个方向的每一个分支后，再获取到最小的那支**

这时我们可以先单看一个方向的分支，**比如上分支**

这是问题就转变成，**如何求出矩阵中某一点往上延伸的最大值**了

这时就能想到可以**使用动态规划来求解**了。每一点能往上延伸的最大长度都与其上方一点和自身状态有关

- 如果自身本身就不能选，直接置为0
- 如果自身可以选，则是在上一点的数量上加1
- **即`dp[i][j] = dp[i][j]==0 ? 0 : dp[i-1][j] + 1`**

同理，**对任意一个方向都能如此处理**

这样也就是进行4次双重循环就能将每个分支求出来

但是实际上也是能**优化进一个双重循环的**

- 上分支，相当于先从左到右，再从上到下
- 下分支，相当于先从左到右，再从下到上
- 左分支，相当于先从上到下，再从左到右
- 右分支，相当于先从上到下，再从右到左
- 这里需要设置3个变量控制指针移动的方向即可，**具体的推荐直接看代码，更清晰**

---

## 对应代码

```java
class Solution {
    public int orderOfLargestPlusSign(int n, int[][] mines) {
        // 以(i,j)为中心最大的阶数
        int[][] dp = new int[n][n];
        // 初始化，全部置为最大，但将mines中的点置为0
        for (int[] e : dp) Arrays.fill(e, n);
        for (int[] e : mines) dp[e[0]][e[1]] = 0;

        for (int i = 0; i < n; ++i) {
            // 记录4个方向的连续1的最大个数
            int left = 0, right = 0, up = 0, down = 0;
            for (int j = 0, k = n - 1; j < n; ++j, --k) {
                // 非0则加1，为0则置0
                left = dp[i][j] > 0 ? left + 1 : 0;
                right = dp[i][k] > 0 ? right + 1 : 0;
                up = dp[j][i] > 0 ? up + 1 : 0;
                down = dp[k][i] > 0 ? down + 1 : 0;
                // i,j 相当于先从上到下，再从左到右，即左支
                dp[i][j] = Math.min(dp[i][j], left);
                // i,k 相当于先从上到下，再从右到左，即右支
                dp[i][k] = Math.min(dp[i][k], right);
                // j,i 相当于先从左到右，再从上到下，即上支
                dp[j][i] = Math.min(dp[j][i], up);
                // k,i 相当于先从左到右，再从下到上，即下支
                dp[k][i] = Math.min(dp[k][i], down);
            }
        }
        int res = 0;
        for (int[] e : dp) {
            // 获取到最大的值
            res = Math.max(res, Arrays.stream(e).max().getAsInt());
        }
        return res;
    }
}
```

---

## 最后

动态规划？不行，快进到直接暴力求解