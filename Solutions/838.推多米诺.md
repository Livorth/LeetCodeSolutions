# [838. 推多米诺](https://leetcode-cn.com/problems/push-dominoes/)

`n` 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。

给你一个字符串 `dominoes` 表示这一行多米诺骨牌的初始状态，其中：

- `dominoes[i] = 'L'`，表示第 i 张多米诺骨牌被推向左侧，
- `dominoes[i] = 'R'`，表示第 i 张多米诺骨牌被推向右侧，
- `dominoes[i] = '.'`，表示没有推动第 i 张多米诺骨牌。

返回表示最终状态的字符串。

**示例 1：**

> 输入：dominoes = "RR.L"
> 输出："RR.L"
> 解释：第一张多米诺骨牌没有给第二张施加额外的力。

**示例 2：**

![img](http://pic.livorth.cn/img/domino.png)

> 输入：dominoes = ".L.R...LR..L.."
> 输出："LL.RR.LLRRLL.."

**提示：**

- `n == dominoes.length`
- `1 <= n <= 105`
- `dominoes[i]` 为 `'L'`、`'R'` 或` '.'`

---

## 题目分析

简单来说就是给你**一串**的多米洛骨牌

然后在某一个时刻有一只无形的手会**同时推动**推动**任意数量**的骨牌

每个骨牌**可以往左推**也**可以往右推**

在骨牌被推动后它自然会往对应的方向倒，带动着旁边的骨牌一起到

**这个过程中的速度是均匀的**

这个题目令我想到了早几天做过的[1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

只不过本题是一维的，上面这题是二维的，单本质上都是试用**多源广度优先遍历**

广度优先遍历在[1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)中已经体验过了，这里就不再过多赘述

---

## 解题思路

其实除了从**被施加力了的骨牌出发**，还有一个角度就是从**没被施加力了的骨牌出发**

因为一个没有施加力的骨牌，他之后**受到其两边的骨牌给他带来的影响**

然后将情况推广，可以**将连续的未被施加力的骨牌看成一个整体**

**那么就是下面几种情况：**
![1645430453(1).jpg](http://pic.livorth.cn/img/1645430483-pVGuPa-1645430453(1).jpg)
**这样我们就能直接对每个不受力的区间进行分析**

- 左右两边都往左，全部倒为左
- 左右两边都往右，全部倒为右
- 左右两边往中间，左边一半往右，右边一半往左，**正中间的不变**

分析出来情况，接下来就是判断出那些是**连续的未被施加力的骨牌**

很简单，使用使用**双指针进行遍历**就行了

- 左指针指向不受力骨牌区间的最左侧

- 右指针指向不受力骨牌区间的最右侧

然后分别往两边延伸一块骨牌用于**判断状态**，再结合上述分析的情况进行判断
**注意：**这里要考虑到的特殊情况就是**起始位置和结束位置**

---

## 对应代码

```java
class Solution {
    public String pushDominoes(String dominoes) {
        char[] c = dominoes.toCharArray();
        int n = c.length;

        for(int i = 0; i < n; i++){
            // 只有原本不被操作才可能产生变化
            if(c[i] == '.'){
                int left = i;
                // 如果‘.’连续，一并讨论
                while(i < n && c[i] == '.'){
                    i++;
                }
                int right = i;

                // 当前区间最左侧骨牌不会影响到当前情况时候
                if(left == 0 || c[left-1] == 'L') {
                    // 统一往左倒
                    if(right < n && c[right] == 'L'){
                        for(int j = left; j < right; j++){
                            c[j] = 'L';
                        }
                    }
                }
                else{
                    // 当前区间最右侧骨牌不会影响到当前情况时候
                    if(right == n || c[right] == 'R'){
                        // 统一往右倒
                        for(int j = left; j < right; j++){
                            c[j] = 'R';
                        }
                    }
                    // 两边的骨牌往中间倒
                    else{
                        while(left < right - 1){
                            c[left] = 'R';
                            c[right-1] = 'L';
                            left++;
                            right--;
                        }
                    }
                }
            }
        }
        return String.valueOf(c);
    }
}
```

![image.png](http://pic.livorth.cn/img/1645429558-wedVgi-image.png)

---

## 结语

题目不算难，偏简单的中等题

使用BFS做略显麻烦

