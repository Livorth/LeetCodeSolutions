# [2055. 蜡烛之间的盘子](https://leetcode-cn.com/problems/plates-between-candles/)

给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 `s` ，它只包含字符 `'*' `和 `'|' `，其中` '*' `表示一个 **盘子** ，`'|' `表示一支 **蜡烛** 。

同时给你一个下标从 **0** 开始的二维整数数组 `queries `，其中 `queries[i] = [lefti, righti]` 表示 **子字符串** `s[lefti...righti] `（**包含左右端点的字符**）。对于每个查询，你需要找到 **子字符串中** 在 **两支蜡烛之间** 的盘子的 **数目** 。如果一个盘子在 **子字符串中** 左边和右边 **都** 至少有一支蜡烛，那么这个盘子满足在 **两支蜡烛之间** 。

比方说，`s = "||**||**|*"` ，查询 `[3, 8] `，表示的是子字符串 `"*||**|" `。子字符串中在两支蜡烛之间的盘子数目为 `2` ，子字符串中右边两个盘子在它们左边和右边 **都** 至少有一支蜡烛。
请你返回一个整数数组 `answer `，其中` answer[i]` 是第` i` 个查询的答案。

 

**示例 1:**

![ex-1](https://pic.livorth.cn/img/ex-1.png)

> 输入：s = "**|**|***|", queries = [[2,5],[5,9]]
> 输出：[2,3]
> 解释：
>
> - queries[0] 有两个盘子在蜡烛之间。
> - queries[1] 有三个盘子在蜡烛之间。

**示例 2:**

![ex-2](https://pic.livorth.cn/img/ex-2.png)

> 输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
> 输出：[9,0,0,0,0]
> 解释：
>
> - queries[0] 有 9 个盘子在蜡烛之间。
> - 另一个查询没有盘子在蜡烛之间。

**提示：**

- `3 <= s.length <= 10^5`
- `s` 只包含字符` '*' `和 `'|' `。
- `1 <= queries.length <= 10^5`
- `queries[i].length == 2`
- `0 <= left <= right < s.length`

## 题目分析

题目将给出的是一个只含有 `"*"`与`"|"`的字符串

其中 `"*"`代表盘子，`"|"`代表蜡烛

然后题目还会给我们一系列的区间左右下标，我们需要找到这些映射到字符串中的区间中，**被蜡烛围住的盘子数量**

**示例2就非常好地阐述了几种情况：**

![image-20220308122046249](https://pic.livorth.cn/img/image-20220308122046249.png)

> 1. 盘子不算的情况
> 	1. 区间的两头部分盘子并没有被蜡烛围到
> 	2. 被围住的区间里没有盘子
> 	3. 区间里只有一根蜡烛，无法围住盘子
>
> 2. 只有被蜡烛完整围住的盘子才能计数

---

## 解题思路

这里我们先针对每个单独的区间来讨论

拿到一个区间，我们根据上面的推断，首先就能想到需要**判断在区间中的蜡烛存在情况**

稍作思考可以想到：我们优先应该求出**最靠近区间左边界的蜡烛**与**最靠近区间右边界的蜡烛**

然后**得到一个被蜡烛围住的一个新区间**，**只要将新区间里面的蜡烛数量减去**，剩下的数量就是我们要的结果了

这样，我们就得到了下面三个**新问题**：

1. 如何快速求出**最靠近区间左边界的蜡烛**
2. 如何快速求出**最靠近区间右边界的蜡烛**
3. 如何快速求出**新区间里面的蜡烛数量**

**很简单，用前缀和就好了**

1. 问题1：使用一个数组，**记录往前走最近的一个蜡烛的下标**，这里需要从前往后遍历更新数组
2. 问题2：使用一个数组，**记录往后走最近的一个蜡烛的下标**，这里需要从后往前遍历更新数组
3. 问题3：使用一个数组，**记录从最开始一位到当前位置蜡烛的数量**，这里需要从前往后遍历更新数组

也就是**遍历两边**就可以了

---

## 对应代码

```java
class Solution {
    public int[] platesBetweenCandles(String s, int[][] queries) {
        int n = s.length();
        int candle = -1;
        int num = 0;

        char[] arr = s.toCharArray();
        // 记录当前位置之前最近的一个蜡烛位置
        int[] preCandles = new int[n];
        // 记录当前位置之后最近的一个蜡烛位置
        int[] afterCandles = new int[n];
        // 记录直到当前位置已经有的蜡烛数量
        int[] preNums = new int[n];

        // 正这来一遍，统计preCandles与preNums
        for(int i = 0; i < n; i++){
            if(arr[i] == '|'){
                candle = i;
                num++;
            }
            preCandles[i] = candle;
            preNums[i] = num;
        }

        candle = -1;
        // 反过来遍历一次，统计afterCandles
        for(int i = n - 1; i >= 0; i--){
            if(arr[i] == '|'){
                candle = i;
            }
            afterCandles[i] = candle;
        }

        int m = queries.length;
        int[] ans = new int[m];
        // 遍历每个区间
        for(int i = 0; i < m; i++){
            // 找到分别离区间最近的两个蜡烛
            int l = afterCandles[queries[i][0]];
            int r = preCandles[queries[i][1]];
            // 只有一根蜡烛或者没有蜡烛，返回0
            if(l == -1 || r == -1 || l >= r){
                ans[i] = 0;
            }
            else{
                // 两个蜡烛之间的所有种类的数量，减去蜡烛的部分
                ans[i] = r - l - (preNums[r] - preNums[l]);
            }
        }
        return ans;
    }
}
```

![image.png](https://pic.livorth.cn/img/1646712498-trtrRZ-image.png)

---

## 最后

重点在于**如何快速找到分别离区间最近的两个蜡烛**

我开始的时候使用**while**找的，于是看到了某个逆天的样例

![image-20220308125006090](https://pic.livorth.cn/img/image-20220308125006090.png)

