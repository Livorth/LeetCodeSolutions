# [1402. 做菜顺序](https://leetcode.cn/problems/reducing-dishes/)

一个厨师收集了他 `n` 道菜的满意程度 `satisfaction` ，这个厨师做出每道菜的时间都是 1 单位时间。

一道菜的 「 **like-time 系数** 」定义为烹饪这道菜结束的时间（包含之前每道菜所花费的时间）乘以这道菜的满意程度，也就是 `time[i]`*`satisfaction[i]` 。

返回厨师在准备了一定数量的菜肴后可以获得的最大 **like-time 系数** 总和。

你可以按 **任意** 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。

**示例 1：**

```
输入：satisfaction = [-1,-8,0,5,-9]
输出：14
解释：去掉第二道和最后一道菜，最大的 like-time 系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。
```

**示例 2：**

```
输入：satisfaction = [4,3,2]
输出：20
解释：可以按照任意顺序做菜 (2*1 + 3*2 + 4*3 = 20)
```

**示例 3：**

```
输入：satisfaction = [-1,-4,-5]
输出：0
解释：大家都不喜欢这些菜，所以不做任何菜就可以获得最大的 like-time 系数。
```

**提示：**

- `n == satisfaction.length`
- `1 <= n <= 500`
- `-1000 <= satisfaction[i] <= 1000`

---

## 题目分析

一开始拿到题目我简单的以为只要简单的将所有负满意度的菜全部删除就是结果，直到我看了第一个示例

其实我们可以将题目最主干的部分提取出来：

- 题目将给我们一个数组：`satisfaction[n]`，而我们需要挑选出n个菜，这里令我们挑出来的菜为`a[n]`
- 令：**like-time[i] = `(i + 1)`*`a[i]` ，这里time[i]事实上只与对应菜品所在位置有关，而一个菜对应一个时间单位，所以转为**`i+1`**

- 而我们最终的目的就是求出全部**`sum(like-time[i]) (0<=i<n)`**的最大值

---

## 解题思路

从我们最朴素的想法出发，我们会首先想到我只要选择满意度尽可能大的菜品放入`a[n]`即可

那么我们还是首先对`satisfaction[n]`进行从大到小排序，然后从头开始选择正满意度的菜品

例如示例一：

> {-1,-8,0,5,-9} --> {5,0,-1,-8,-9}

但是我们会发现

- 只选择第一个菜的时候，**`sum(like-time[i])`**= `5*1`

- 选择前两个菜的时候，**`sum(like-time[i])`**= `5*2 + 0*1`

- 选择前三个菜的时候，**`sum(like-time[i])`**= `5*3 + 0*2 + -1*1`
- 选择前四个菜的时候，**`sum(like-time[i])`**= `5*4 + 0*3 + -1*2 + -8*1`

- ……

由此我们可以发现，每次对选择一个菜品，就会使得**`sum(like-time[i])`**加上一个 **菜品满意度的前缀和preSum**

由于每次都是加上的前缀和，那么只要前缀和不为负，那么**`sum(like-time[i])`**就能一直增大，直到前缀和为负数为止

- 即：**`sum(like-time[i])` = sum(like-time[i - 1]) + preSum[i]**

这样我们编码的思路也就出来了

1. 从大到小对`satisfaction[n]`排序
2. 遍历`satisfaction[n]`中的每一个元素
   1. 计算并记录直到当前元素的前缀和
   2. 计算并记录**`sum(like-time[i])` = sum(like-time[i - 1]) + preSum[i]**
3. 直到`preSum[i]`为负，跳出循环并返回结果

---

## 对应代码

```java
/**
     * 第一眼排序，只留下所有正满意度的菜下来加起来不就好了吗
     * 第二眼看到第一个示例好像不太一样，因为选了-1后，5可以从*2变为*3
     * 后面只要简单找下规律就知道是否要选某个负满意度的菜了
     * 执行耗时:1 ms,击败了100.00% 的Java用户
	 *  内存消耗:39.3 MB,击败了73.76% 的Java用户
     */
class Solution {
    public int maxSatisfaction(int[] satisfaction) {
        Arrays.sort(satisfaction);
        // 从最大到最小的满意度和，就是后缀和
        int preSum = 0;
        int res = 0;
        for (int i = satisfaction.length - 1; i >= 0; i--) {
            preSum += satisfaction[i];
            if (preSum <= 0) break;
            // 每多选一道菜就加一次前缀和
            res += preSum;
        }
        return res;
    }
}
```

### 复杂度分析

#### 时间复杂度

代码的循环只由两个部分构成：

- 排序O(n logn)
- 遍历O(n)

就是最终时间复杂度为O(n logn)

#### 空间复杂度

除去排序消耗的部分，仅用了两个变量存储前缀和和最终结果，计为O(1)

---

## 最后

相当简单的“困难”题，基本上没有任何的弯弯绕绕，可以直接通过示例看出解题思路与方法
