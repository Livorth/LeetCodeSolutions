# [907.子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。

由于答案可能很大，因此 **返回答案模 `10^9 + 7`** 。

**示例 1：**

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

**示例 2：**

```
输入：arr = [11,81,94,43,3]
输出：444
```

**提示：**

- `1 <= arr.length <= 3 * 104`
- `1 <= arr[i] <= 3 * 104`

**Related Topics**

- 栈
- 数组
- 动态规划
- 单调栈

---

## 题目分析

简单来说就是找到arr中的**每一个连续的子数组**，然后求出每一个子数组中**最小值的和**

其实与其说是求出每一个子数组，不如说是**求出每一个数作为某一个子数组的最小值的次数**

毕竟只要求出每个数作为最小值的次数之后，只要进行简单的统计就能得到最终的结果

![image-20221101104011690](https://pic.livorth.cn/img/image-20221101104011690.png)

在上图中的：

- 对1来说，在arr[0,3]这个区间内，它都是最小值，那么
  - 子数组的左边界可以是：3,1
  - 子数组的右边界可以是：1,2,4
  - 一共2*3=6个子数组
- 对2来说，在arr[2,3]这个区间内，它都是最小值，那么
  - 子数组的左边界可以是：2
  - 子数组的右边界可以是：2,4
  - 一共1*2=2个子数组

---

## 解题思路

通过对题目的分析，我们已经可以知道，我们的目标就是求出**每一个数作为最小值的次数**

那么现在的问题就是如何获取到这个次数

获取到次数的关键就是在于判断出当前数能在哪一个范围内作为最小值

比如1，在整个arr数组中都是最小值，所以范围就是arr[0,3]

而2，1就在它的左边，于是它的范围就只能是arr[2,3]

由此我们可以得出结论，范围取决于其两边比当前数更小的元素位置

**而这种情况下，用单调栈是最合适的**

在本题中使用**单调递增栈**

1. 遍历每一个数
2. 尝试将当前数放进栈中
3. 如果栈顶元素比当前元素更小，则说明**当前数范围的左边界就是栈顶元素的位置**
4. 如果栈顶元素比当前元素更大，则将栈顶元素出栈，然后再回到第二步中，继续尝试

通过上述过程就能求出每一个数的左边界，**同理我们从后往前遍历一次arr，我们也可以获得到每一个数的右边界**

然后我们可以通过边界与当前数的位置关系或得到当前数作为最小值的范围，以及其左右边界的个数，并最终获得结果

但是仅仅是这样就可以了吗？事实上可以进行优化的地方还很多

1. 最起码就是能使用数组模拟栈，将ArrayDeque优化成数组
2. 我们**并没有遍历第二次求右边界的必要**，因为实际上在获取左边界的首次遍历中，出栈的过程其实就能表示：**出栈元素的右边界就是当前这个尝试入栈的元素**，只有因为当前元素比出栈元素更小它们才能出栈不是吗？
3. 我们甚至可以不需要在最后遍历每个数字的两个边界才能算出这个数对结果的影响，因为在求出某一个数的右边界的时候，即其出栈的时候，**这个数的左边界就是新的栈顶元素**，当前元素属于是被夹在这个中间了。

---

## 代码

```java
class Solution {
    private static final long MOD = (long) 1e9 + 7;

    /**
     * 采用三次遍历的方法
     * 执行耗时:21 ms,击败了70.51% 的Java用户
     * 内存消耗:48.7 MB,击败了68.27% 的Java用户
     */
    public int sumSubarrayMins3(int[] arr) {
        long ans = 0L;
        int n = arr.length;
        int[] left = new int[n];
        int[] right = new int[n];
        ArrayDeque<Integer> st = new ArrayDeque<Integer>();
        st.push(-1);
        for (int i = 0; i < n; ++i) {
            while (st.size() > 1 && arr[st.peek()] >= arr[i])
                st.pop();
            left[i] = st.peek();
            st.push(i);
        }


        st.clear();
        st.push(n);
        for (int i = n - 1; i >= 0; --i) {
            while (st.size() > 1 && arr[st.peek()] > arr[i])
                st.pop();
            right[i] = st.peek();
            st.push(i);
        }


        for (int i = 0; i < n; ++i)
            ans += (long) arr[i] * (i - left[i]) * (right[i] - i);
        return (int) (ans % MOD);
    }

    /**
     * 采用两次遍历的方法
     * 执行耗时:5 ms,击败了99.77% 的Java用户
     * 内存消耗:49.5 MB,击败了5.18% 的Java用户
     */
    public int sumSubarrayMins2(int[] arr) {
        long ans = 0L;
        int n = arr.length;
        int[] st = new int[n + 1];
        int top = 0;
        // 分别存储锚定值左右两边最小的值
        int[] left = new int[n];
        int[] right = new int[n];

        // 相当于在数组前设置一个值为-1的哨兵，确保栈中所有元素都能出栈
        st[top++] = -1;
        for (int i = 0; i < n; ++i) {
            // 右边界默认为数组最右侧
            right[i] = n;
            while (top > 1 && arr[st[top - 1]] >= arr[i]) {
                // i恰好比每一个出栈的元素小，由此作为出栈元素的右边界
                right[st[--top]] = i;
            }
            // 更新i的左边界
            left[i] = st[top - 1];
            st[top++] = i;
        }

        // 通过辅助数组获取每个锚定值的左右边界并计算出贡献值
        for (int i = 0; i < n; ++i)
            ans += (long) arr[i] * (i - left[i]) * (right[i] - i);
        return (int) (ans % MOD);
    }

    /**
     * 采用一次遍历的方法
     * 执行耗时:5 ms,击败了99.77% 的Java用户
     * 内存消耗:42 MB,击败了96.60% 的Java用户
     */
    public int sumSubarrayMins1(int[] arr) {
        long ans = 0L;
        int n = arr.length;
        int[] st = new int[n + 1];
        int top = 0;
        // 相当于在数组前设置一个值为-1的哨兵，确保栈中所有元素都能出栈
        st[top++] = -1;
        for (int r = 0; r <= n; ++r) {
            // 尾部哨兵，同样确保栈中所有元素都能出栈
            int x = r < n ? arr[r] : -1;
            // 单调递增栈
            while (top > 1 && arr[st[top - 1]] >= x) {
                // i即为当前锚定的值
                int i = st[--top];
                // st新的栈顶元素即左边界，r即为右边界，中间的部分则是i的势力范围
                ans += (long) arr[i] * (i - st[top - 1]) * (r - i);
            }
            st[top++] = r;
        }
        return (int) (ans % MOD);
    }
}
```

---

## 最后

优化的过程可能得自己手动推一下可能才更好理解。