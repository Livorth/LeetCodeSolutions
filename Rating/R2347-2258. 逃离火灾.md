---
title: R2347-2258. 逃离火灾
time: 2023-11-29
tags:
  - 题解
  - bfs
cssclasses:
  - 力扣题解
rating: "2347"
---
# [2258. 逃离火灾](https://leetcode.cn/problems/escape-the-spreading-fire/)
## 题目详情

给你一个下标从 **0** 开始大小为 `m x n` 的二维整数数组 `grid` ，它表示一个网格图。每个格子为下面 3 个值之一：

- `0` 表示草地。
- `1` 表示着火的格子。
- `2` 表示一座墙，你跟火都不能通过这个格子。

一开始你在最左上角的格子 `(0, 0)` ，你想要到达最右下角的安全屋格子 `(m - 1, n - 1)` 。每一分钟，你可以移动到 **相邻** 的草地格子。每次你移动 **之后** ，着火的格子会扩散到所有不是墙的 **相邻** 格子。

请你返回你在初始位置可以停留的 **最多** 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 `-1` 。如果不管你在初始位置停留多久，你 **总是** 能到达安全屋，请你返回 `109` 。

注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

如果两个格子有共同边，那么它们为 **相邻** 格子。

**示例 1：**

![](https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg)

> **输入：** `grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]`
> **输出：** 3
> **解释：** 上图展示了你在初始位置停留 3 分钟后的情形。
> 你仍然可以安全到达安全屋。
> 停留超过 3 分钟会让你无法安全到达安全屋。

**示例 2：**

![](https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg)

> **输入：** `grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]`
> **输出：**-1
> **解释：** 上图展示了你马上开始朝安全屋移动的情形。
> 火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。
> 所以返回 -1 。

**示例 3：**

![](https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg)

> **输入：** `grid = [[0,0,0],[2,2,0],[1,2,0]]`
> **输出：** 1000000000
> **解释：** 上图展示了初始网格图。
> 注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。
> 所以返回 10^9 。

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `2 <= m, n <= 300`
- `4 <= m * n <= 2 * 104`
- `grid[i][j]` 是 `0` ，`1` 或者 `2` 。
- `grid[0][0] == grid[m - 1][n - 1] == 0`

Related Topics
- 广度优先搜索
- 数组
- 二分查找
- 矩阵

---
## 题目分析

头一次看到火来了还不跑，还要写几个BFS算一下自己晚走几步才能刚刚好不被烧死的
本题和常见的火烧人逃问题是类似的，只是常见的火烧问题是判断人是否能逃掉而

题目中存在着几个关键点能帮我快速确定算法中的相关处理方法
- 起火点多个且不固定：**多源BFS**
- 人是用矩阵的`(0,0)`出发到达`(n,n)`：bfs或者dfs寻找最短路

然后还有一个比较坑的地方在于
> 如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

也就是在安全屋这个位置的判断逻辑和其他的地方是不一样的，在

但是题目最麻烦的地方在于，**确定人可以在等待多久后再出发还能不被烧到？**
这里我们有多种做法：
1. 最简单的是一个一个试，等1步行不行？等2步行不行？
	- 直接遍历的效率略低，可以改为二分查找，从O(n)到O(logn)
2. 构建两个数组，分别维护人和火到每个格子的位置，通过这两个数组来动态维护一个数组，这个数组记录人到(i,j)这个位置能等待多久时间

---
## 解题思路

这两做法，第一种的实现更简单一点，这里主要讲第二种
我们主要分为两步走
1. 计算并用fireMap存储每个草地的最短时间
2. 计算并用manMap存储起点到每个点可以停留的最长分钟数
>这里构建了两个数组辅助计算，其实也可以使用第三个数组存储人到每个草地的最短时间，但是在bfs的过程中可以直接通过传值的方式计算，就省略了这个数组

### 1. 计算fireMap
1. 首先初始化fireMap，是的其中每个位置的数值大小都**初始化为0x3f3f3f3f**，便于后续计算
2. 由于是**多源bfs**，所以需要先将地图中所有值为1的位置信息加入到队列中
3. 计算最短时间就是常规bfs思路，但是在计算的时候要主要是**当前计算的结果大于这个位置以及有的最短时间，就不用重复计算了**

**注意点：**
由于如果人到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋，所以我们需要把终点值加一，即`fireMap[n - 1][m - 1]++`
### 2. 计算manMap
1. 初始化manMap，在之前已经计算过火到每个点的距离了，于是也就是知道了火到(0,0)的时间，那么`manMap[0][0] = fireMap[0][0] - 1`，而其他的点初始化为-1，表示还走不到
2. 人的bfs为单源bfs，所以其实用dfs也是能做的
3. 在bfs的时候需要注意
	- 如果你走到的那块草坪**在你到了的那分钟内就会起火，就别去了**，找烧
	- 当前位置的最小时间为：**火到当前位置的时间 - 人到当前位置的时间 - 1**（减1是因为你得在火到之前离开这个位置）
	- 如果算出来的时间比之前记录的还要小，那么则需要更新当前位置，并以当前位置往四周扩散重新计算一次
由于manMap存储的是**起点到每个点可以停留的最长分钟数**，那么我们最终需要的结果就是`manMap[n - 1][m - 1]`
### 3. 返回结果
这里我们还要判断的是**火能不能烧到安全屋**，如果要是烧不到，那么`manMap[0][0]`的数值为`0x3f3f3f3f`, 而`manMap[n - 1][m - 1]`的数值应该就应该为`0x3f3f3f3f - n * m`，这个时候我们就应该要返回10^9

---
## 对应代码

```java
/**  
 * 两遍bfs  
 * 第一遍bfs统计出每个地点起火的时间  
 * 第二遍bfs统计出人到每个地点能等待的最长时间  
 * 执行耗时:11 ms,击败了95.00% 的Java用户  
 * 内存消耗:44.3 MB,击败了53.41% 的Java用户  
 */  
class Solution {  
    private final int[][] DIRS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  
  
    public int maximumMinutes(int[][] grid) {  
        int n = grid.length, m = grid[0].length;  
        // 1. bfs求出每个点起火的最早时间  
        // 1.1. 初始化fireMap数组，用于存储每个点起火的最短时间  
        int[][] fireMap = new int[n][m];  
        for (int i = 0; i < n; i++) {  
            Arrays.fill(fireMap[i], 0x3f3f3f3f);  
        }  
        // 1.2. bfs计算每个点的起火时间  
        Deque<int[]> que = new ArrayDeque<>();  
        for (int i = 0; i < n; i++) {  
            for (int j = 0; j < grid[i].length; j++) {  
                if (grid[i][j] == 1) {  
                    que.add(new int[]{i, j});  
                    fireMap[i][j] = 0;  
                }  
            }  
        }  
        while (!que.isEmpty()) {  
            int[] nowFire = que.poll();  
            int value = fireMap[nowFire[0]][nowFire[1]];  
            // 枚举当前点的4个方向  
            for (int[] d : DIRS) {  
                int x = nowFire[0] + d[0], y = nowFire[1] + d[1];  
                if (0 <= x && x < n && 0 <= y && y < m  
                        && grid[x][y] == 0 && fireMap[x][y] > value + 1) {  
                    fireMap[x][y] = value + 1;  
                    que.add(new int[]{x, y});  
                }  
            }  
        }  
        // 注意点：如果人到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。所以我们需要把终点值加一。  
        fireMap[n - 1][m - 1]++;  
        // 2. 计算起点到每个点可以停留的最长分钟数  
        // 2.1. 初始化manMap数组，用于存储每个点最长等待时间  
        int[][] manMap = new int[n][m];  
        for (int i = 0; i < n; i++) {  
            Arrays.fill(manMap[i], -1);  
        }  
        manMap[0][0] = fireMap[0][0] - 1;  
        // 2.1. bfs计算每个点人最多的等待时间  
        // 第三个参数用于存储人到那个点的最短时间，用于计算出最长的等待时间  
        que.add(new int[]{0, 0, 0});  
        while (!que.isEmpty()) {  
            int[] nowMan = que.poll();  
            int value = manMap[nowMan[0]][nowMan[1]];  
            for (int[] d : DIRS) {  
                int x = nowMan[0] + d[0], y = nowMan[1] + d[1];  
                if (0 <= x && x < n && 0 <= y && y < m  
                        && grid[x][y] != 2 && fireMap[x][y] > nowMan[2] + 1) {  
                    // 火到当前位置的时间 - 人到当前位置的时间 - 1（减1是因为你得在火到之前离开这个位置）  
                    int min = Math.min(value, fireMap[x][y] - (nowMan[2] + 1) - 1);  
                    // 更新当前位置的最小时间，并继续bfs  
                    if (manMap[x][y] < min) {  
                        manMap[x][y] = min;  
                        que.add(new int[]{x, y, nowMan[2] + 1});  
                    }  
                }  
            }  
        }  
        // 火到不了则1e9  
        if (manMap[n - 1][m - 1] >= 0x3f3f3f) return (int) 1e9;  
        return manMap[n - 1][m - 1];  
    }  
}
```
### 复杂度分析

我们总共用了两个bfs来计算，所以时间复杂度为O(mn)
同时也建立了两个二维数组来辅助，空间复杂度也是O(mn)

---
## 最后

这个题目还是相当麻烦的，细节相当多，加上是广度优先搜索，也不好调试
这次的题解写的有点乱，说实话不如直接看代码清晰明了

