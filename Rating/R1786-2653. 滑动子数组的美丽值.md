---
title: R1786-2653. 滑动子数组的美丽值
time: 2024-02-04
tags:
  - 题解
  - 定长滑动窗口
  - 滑动窗口
  - 计数排序
cssclasses:
  - 力扣题解
rating: "1786"
---
# [2653. 滑动子数组的美丽值](https://leetcode.cn/problems/sliding-subarray-beauty/)
## 题目详情
给你一个长度为 `n` 的整数数组 `nums` ，请你求出每个长度为 `k` 的子数组的 **美丽值** 。

一个子数组的 **美丽值** 定义为：如果子数组中第 `x` **小整数** 是 **负数** ，那么美丽值为第 `x` 小的数，否则美丽值为 `0` 。

请你返回一个包含 `n - k + 1` 个整数的数组，**依次** 表示数组中从第一个下标开始，每个长度为 `k` 的子数组的 **美丽值** 。

- 子数组指的是数组中一段连续 **非空** 的元素序列。s

**示例 1：**

> **输入：**`nums = [1,-1,-3,-2,3], k = 3, x = 2`
> **输出：**`[-1,-2,-2]`
> **解释：** 总共有 3 个 k = 3 的子数组。
> 第一个子数组是 `[1, -1, -3]` ，第二小的数是负数 -1 。
> 第二个子数组是 `[-1, -3, -2]` ，第二小的数是负数 -2 。
> 第三个子数组是 `[-3, -2, 3] ，第二小的数是负数 -2 。`

**示例 2：**

> **输入：**`nums = [-1,-2,-3,-4,-5], k = 2, x = 2`
> **输出：**`[-1,-2,-3,-4]`
> **解释：** 总共有 4 个 k = 2 的子数组。
> `[-1, -2] 中第二小的数是负数 -1 。`
> `[-2, -3] 中第二小的数是负数 -2 。`
> `[-3, -4] 中第二小的数是负数 -3 。`
> `[-4, -5] 中第二小的数是负数 -4 。`

**示例 3：**

> **输入：**`nums = [-3,1,2,-3,0,-3], k = 2, x = 1`
> **输出：**`[-3,0,-3,-3,-3]`
> **解释：** 总共有 5 个 k = 2 的子数组。
> `[-3, 1] 中最小的数是负数 -3 。`
> `[1, 2] 中最小的数不是负数，所以美丽值为 0 。`
> `[2, -3] 中最小的数是负数 -3 。`
> `[-3, 0] 中最小的数是负数 -3 。`
> `[0, -3] 中最小的数是负数 -3 。`

**提示：**
- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= k <= n`
- `1 <= x <= k`
- `-50 <= nums[i] <= 50`

Related Topics
- 数组
- 哈希表
- 滑动窗口

---
## 题目分析

题目的目的是找出给出的nums数组中，全部**长度为k的连续子数组**，然后求出每个子数组中第x小的元素
只是如果第x小的元素为正数的时候记为0而已

---
## 解题思路

按照示例来看，基本是是明示了，就是定长的滑动窗口
每滑动一次就计算一次当前窗口中第x小的元素

但是很显然我们不可能每次都遍历一次滑动窗口中的每一个元素并对他进行快速选择，这样太慢了
由于我们每次滑动窗口的时候，**都会使窗口内的元素去头加尾，于是就想到了计数排序**
- 只要完成了初始化，每次就能在辅助数组中O(1)完成计数
- 完成了计数的同时也完成了排序，我们只需要找到对应位置的x即可

>同理我们还可以维护当前窗口中第x小的元素，然后在滑动之后判断出去的元素和进来的元素是否会对当前的x带来影响，然后根据X在技术数组中的相对位置进行前后移动即可

---
## 对应代码

```java
/**
 * 定长滑动窗口 + 计数排序
 * 执行耗时:39 ms,击败了52.63% 的Java用户
 * 内存消耗:62 MB,击败了15.04% 的Java用户
 */
class Solution {
	public int[] getSubarrayBeauty(int[] nums, int k, int x) {
		int[] counting = new int[106];
		int[] res = new int[nums.length - k + 1];
		// 初始化
		for (int i = 0; i < k; i++) {
			counting[nums[i] + 50]++;
		}
		res[0] = getTheX(counting, x);
		for (int i = k; i < nums.length; i++) {
			counting[nums[i - k] + 50]--;
			counting[nums[i] + 50]++;
			res[i - k + 1] = getTheX(counting, x);
		}
		return res;
	}

	// 计数排序获取第x大的元素
	private int getTheX(int[] counting, int x) {
		int res = 0;
		int count = 0;
		for (int i = 0; i < counting.length; i++) {
			count += counting[i];
			if (count >= x) {
				res = i - 50;
				break;
			}
		}
		return Math.min(res, 0);
	}
}
```
### 复杂度分析

采用定长滑动窗口 + 计数排序的方式进行计算
滑动窗口O(n)，计数排序O(U),U=100
所以时间复杂度为O(Un)
然后使用了一个长度为100的辅助数组用于计数排序空间复杂度为O(U)

---
## 最后

一眼滑动窗口
但是比较麻烦的是怎么尽可能快地求出第X小的元素让我犯了难，一直在想有没有什么O(1)的办法直接求，总感觉下次遇到什么题目是O(n^3)的复杂度能解的时候我却会去想N(nlogn)