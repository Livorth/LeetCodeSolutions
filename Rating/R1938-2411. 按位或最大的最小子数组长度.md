---
title: R1938-2411. 按位或最大的最小子数组长度
time: 2024-04-12
tags:
  - 题解
cssclasses:
  - 力扣题解
rating: "1938"
---
# [2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/)
## 题目详情

给你一个长度为 `n` 下标从 **0** 开始的数组 `nums` ，数组中所有数字均为非负整数。对于 `0` 到 `n - 1` 之间的每一个下标 `i` ，你需要找出 `nums` 中一个 **最小** 非空子数组，它的起始位置为 `i` （包含这个位置），同时有 **最大** 的 **按位或****运算值** 。

- 换言之，令 `Bij` 表示子数组 `nums[i...j]` 的按位或运算的结果，你需要找到一个起始位置为 `i` 的最小子数组，这个子数组的按位或运算的结果等于 `max(Bik)` ，其中 `i <= k <= n - 1` 。

一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。

请你返回一个大小为 `n` 的整数数组 `answer`，其中 `answer[i]`是开始位置为 `i` ，按位或运算结果最大，且 **最短** 子数组的长度。

**子数组** 是数组里一段连续非空元素组成的序列。

**示例 1：**

> **输入：** nums = [1,0,2,1,3]
> **输出：**[3,3,2,2,1]
> **解释：**
> 任何位置开始，最大按位或运算的结果都是 3 。

- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。
- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。
- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。
- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。
- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。
所以我们返回 [3,3,2,2,1] 。

**示例 2：**

> **输入：** nums = [1,2]
> **输出：**[2,1]
> **解释：**
> 下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。
> 下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。
> 所以我们返回 [2,1] 。

**提示：**

- `n == nums.length`
- `1 <= n <= 10^5`
- `0 <= nums[i] <= 10^9`

Related Topics

- 位运算
- 数组
- 二分查找
- 滑动窗口

---
## 题目分析

题目将给出数字数组，而我们要返回一个结果数组res，其中
- res[i]表示，从nums[i]往后能**获得的最大的或运算结果**的**最短子数组长度**
- 注意以下几个关键词：
	- 或运算
	- 最大结果
	- 最短长度
这个数组其中最多能有10^5个数，那么我们的时间复杂度要控制在O(n^2)内，也就是暴力解很有可能会超时
---
## 解题思路

如果说我们直接枚举每一个左端点，同时使用指针遍历其之后的点作为右端点进行计算，这样的时间复杂度是O(n^2)，我试了下超时了
所以必须要换一个思路
我们可以从或运算的性质出发
- 或运算只能**将0变成1**而不能将1变成0
- 或运算后的数字要么是**增大的**，要么就是**不变的**
- 同时我们的int型数，最多只能有30种情况，**是有限的**
**也就是对于左端点`nums[i]`来说，挨个与`nums[j]`进行或运算，其结果`res[i,j]`是阶梯状增加的**
![image.png](https://pic.leetcode.cn/1713164654-vUiyGF-image.png)
对此我们再来考虑`res[i+1]`，可能处于上图第一段阶梯中，也可能处于第二段阶梯的第一个位置，这样其实是不好求的
**但是假设我们看`res[i-1]`呢**
根据我们前面推导的性质可以发现`res[i-1]`的按为或的最大值其实就是 `nums[i-1] | res[i]`
至于子数组的长度，则取决的`res[i-1]`在什么时候可以达到这个最大值
> 因为`nums[i-1]`中本来就有不少位数的1，可能使得部分阶梯提前

由此我们在枚举右端点的时候维护res结果数组，同时遍历如果新加入的右端点能使得
`res[i]`产生变化，那么则说明可以对于`res[i]`来说就是进入了下一个阶梯
同时我们可以发现
>`res[i-1,j] = res[i,j] | nums[i-1]`
如果 `res[i,j+1] = res[i,j] | num[j] = res[i,j]`，即**新加入的右端点任然在同一阶梯上**
那么 `res[i-1,j+1] = res[i,j+1] | nums[i-1] = res[i,j] | nums[i-1]`
**也就是说只要出现`res[i]`在或上`nums[j]`值不变，那从`res[0]`到`res[i-1]`或上`nums[j]`都不会变**

所以对于`res[i]`的更新，我们可以采用从右往左的方式进行遍历，只要遇到或运算后值不变后就跳出循环:
1. 从左到右枚举右端点
2. 从右往左遍历，判断`res[i]`与`nums[j]`或运算后是否能变化
	1. 变化了，更新最短子数组的长度
	2. 不变，跳出循环，因为再往前走也不会变
### 更泛用的模板

这种做法本质上是直接记录阶梯，包括阶梯的左端点、右端点、阶梯值，都可以存起来，取之即用
我们可以定义一个数据结构对上面列举的信息进行存储，比如`List<int[]> steps`，在steps中我们
通过list存储每一个阶梯，同时定义一个int数组存储阶梯的值和阶梯的左端点
1. 从前往后遍历数组中每个节点
2. 将每遍历到的每个节点按照值为0的阶梯加入steps
3. 遍历每个阶梯，都将其值与`nums[i]`进行与操作
	1. 如果阶梯值变化，则插入新的list中
	2. 如果阶梯值与新list中最后的阶梯值相同，则更新新list中最后阶梯值中记录的值
4. 便利完成之后，list中第一位的就是最后的阶梯，以`nums[i]`为左端点的子数组可以达到的最大阶梯就是这个阶梯
**这种解法，就从记录子数组到记录阶梯本身，更加泛化**
其他只要是有能产生阶梯的题目都能用到这种解法

---
## 对应代码



### 复杂度分析



---
## 最后



