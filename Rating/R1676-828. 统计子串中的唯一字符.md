---
title: R1676-828. 统计子串中的唯一字符
time: 2023-11-27
tags:
  - 题解
cssclasses:
  - 力扣题解
rating: "1676"
---
# [828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)
## 题目详情

我们定义了一个函数 `countUniqueChars(s)` 来统计字符串 `s` 中的唯一字符，并返回唯一字符的个数。

例如：`s = "LEETCODE"` ，则其中 `"L"`, `"T"`,`"C"`,`"O"`,`"D"` 都是唯一字符，因为它们只出现一次，所以 `countUniqueChars(s) = 5` 。

本题将会给你一个字符串 `s` ，我们需要返回 `countUniqueChars(t)` 的总和，其中 `t` 是 `s` 的子字符串。输入用例保证返回值为 32 位整数。

注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 `s` 的所有子字符串中的唯一字符）。

**示例 1：**
>**输入:** s = "ABC"
>**输出:** 10
>**解释:** 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10

**示例 2：**
>**输入:** s = "ABA"
>**输出:** 8
>**解释:** 除`了 countUniqueChars`("ABA") = 1 之外，其余与示例 1 相同。

**示例 3：**
>**输入：** s = "LEETCODE"
>**输出：** 92

**提示：**
- `1 <= s.length <= 10^5`
- `s` 只包含大写英文字符

Related Topics
- 哈希表
- 字符串
- 动态规划

---
## 题目分析

题目简单来说就是**列举出字符串s的每一个子字符串**，并找到每个子字符串中有多少个字符**只出现一次**，然后返回其之和

很显然让我们列举出每个子串然后再找到其中哪些字符的出现次数是不现实的，**这种暴力解的时间复杂度能到O(n^3)**，于是我只能另辟蹊径

一般情况下，**我们都是分别迭代子串的头和尾来获取到全部的子串**
通过观察我们可以发现能对结果产生影响的最主要是**在子串尾加入的字符**
- 如果子串中已经有这个字符，则countUniqueChars不变
- 如果子串中没有这个字符，则countUniqueChars不变

那这里假设我们完全不考虑子串头在哪，而是将这些子串**看成一个子串集合**，然后再在这些子串后面**全部加上一个字符呢**？
于是遍引申到：在所有以`s[i-1]`结尾的子串后，插入`s[i]`能对结果产生多少影响?
这里我们假设`s[i]`为`c`，`c`字符在s中上一次出现的位置为`index1`，上上次出现的位置为`index0`
- **对于子串头在`i`到`index1`之间的子串**，这些子串中没有出现过`c`，插入`c`能让它们所有的`countUniqueChars`**全部加1**
- **对于子串头在`index1`到`index0`之间的子串**，这些子串中出现过一次`c`，于是插入`c`后它们所有的`countUniqueChars`**全部减1**
- **对于子串头在`0`到`index0`之间的子串**，这些子串出现过2次`c`了，再次插入**不会产生影响**

到了这一步，答案就呼之欲出了

---
## 解题思路

根据我们前面的分析，我们需要
- 构建两个数组维护每个字符上一次和上上次出现的位置，我这边定义的是一个二维数组`index[26][2]`，其中`index[c][0]`为 字符 c 上上次出现的位置， `index[c][1]`为c上次出现的位置
- 定义一个变量sum维护以`s[i]`结尾的子串集合的`countUniqueChars`之和

然后根据之前分析的3条规则，可以写出维持sum的两条计算式
- **这次的位置到上次的位置每个子串都能加1：`sum += i - index[c][1];`**
- **上次的位置到上上次位置每个子串都要减1：`sum -= index[c][1] - index[c][0];`**

但是我们需要注意一点的是如果当前字符还没有出现过的时候，index要怎么处理？
其实简单来看就是在 **`s[0]`之前再加个字符作为哨兵**
也就是将`index`中的每个位置的初始值都设置为-1，**也就是每个字符上次、上上次出现的位置为-1**

---
## 对应代码
```java
/**  
 * 动态规划，维护以当前位置结尾的子串的countUniqueChars值和  
 * 执行耗时:6 ms,击败了89.69% 的Java用户  
 * 内存消耗:43.3 MB,击败了69.96% 的Java用户  
 */  
class Solution {  
    public int uniqueLetterString(String s) {  
        // 记录字母上两次出现的位置，默认为负一方便后续计算  
        int[][] index = new int[26][2];  
        for (int i = 0; i < 26; i++) {  
            index[i][0] = index[i][1] = -1;  
        }  
        int res = 0;  
        // count记录以当前位置结尾的子串的countUniqueChars值和  
        int sum = 0;  
        byte[] bytes = s.getBytes();  
        for (int i = 0; i < bytes.length; i++) {  
            int c = bytes[i] - 'A';  
            // 当前位置到上一次的位置里的所有子串的count均+1  
            sum += i - index[c][1];  
            // 上次位置到上上次位置的所有子串的count均-1  
            sum -= index[c][1] - index[c][0];  
            res += sum;  
            index[c][0] = index[c][1];  
            index[c][1] = i;  
        }  
        return res;  
    }  
}
```
### 复杂度分析
这个解法的对于传入的s来说只进行了一次一重遍历，也就是**时间复杂度为`O(n)`**
空间上只构建了一个`26*2`的二维数组作为辅助数组，某种程度上算`O(C)`

---
## 最后

其实开始想的时候就想直接构建一个`n*n`的二维数组，存储每个从i开始到j结束的子串的countUniqueChars值，**每次都从后往前遍历**
- 没遇到相同字符的时候+1
- 遇到第一次但是没遇到第二次的时候-1
- 遇到第二次就直接到下一行了

不过这种时间复杂度就O(n^2)了
于是就在想能不能**直接一次性操作多个**，因为从后往前遍历的时候，都是对一个范围内的countUniqueChars值统一加1减1
**于是就想到了能不能直接维护以`s[i]`结尾的子串集合的countUniqueChars值之和**
想到了这一步就简单起来了

