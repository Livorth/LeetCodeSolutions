---
title: R1825-1702. 修改后的最大二进制字符串
time: 2024-04-10
tags:
  - 题解
  - 贪心
  - 模拟
  - 字符串
  - 脑筋急转弯
cssclasses:
  - 力扣题解
rating: "1825"
---
# [1702. 修改后的最大二进制字符串](https://leetcode.cn/problems/maximum-binary-string-after-change/)

## 题目详情

给你一个二进制字符串 `binary` ，它仅有 `0` 或者 `1` 组成。你可以使用下面的操作任意次对它进行修改：

- 操作 1 ：如果二进制串包含子字符串 `"00"` ，你可以用 `"10"` 将其替换。
    - 比方说， "**00**010" -> "**10**010"
- 操作 2 ：如果二进制串包含子字符串 `"10"` ，你可以用 `"01"` 将其替换。
    - 比方说， "000**10**" -> "000**01**"

请你返回执行上述操作任意次以后能得到的 **最大二进制字符串** 。如果二进制字符串 `x` 对应的十进制数字大于二进制字符串 `y` 对应的十进制数字，那么我们称二进制字符串 `x` 大于二进制字符串 `y` 。

**示例 1：**

> **输入：** binary = "000110"
> **输出：**"111011"
> **解释：** 一个可行的转换为：
> "0001**10**" -> "0001**01**" 
> "**00**0101" -> "**10**0101" 
> "1**00**101" -> "1**10**101" 
> "110**10**1" -> "110**01**1" 
> "11**00**11" -> "11**10**11"

**示例 2：**

> **输入：** binary = "01"
> **输出：**"01"
> **解释：**"01" 没办法进行任何转换。

**提示：**
- `1 <= binary.length <= 105`
- `binary` 仅包含 `'0'` 和 `'1'` 。
---
## 题目分析
题目给出的是二进制字符串，其中**只包含 0 和 1**
同时我们拥有两种操作方式
1. 将 00 转变成 10
2. 将 10 转变为 01
我们的目标是使**操作后的字符串的值越大**

我们单纯值看这两个操作那么最多发现 00 除了转为 10 还可以转成 01，不过意义不大
但是如果我们代入某些具体的样例中就会显得不一样
假设我们有一个字符串 0111010
很显然，我们肯定是不能让第一位是一个0的，为了然其更大，**0要尽可能少，尽可能靠后**
> 这里我们聚焦 “01110” 这一小段
> 01110 -> 01101
> 01101 -> 01011
> 01011 -> 00111
> 00111 -> 10111
> 先采用操作2，用一种类似冒泡的方式**将处于后方的0往前移**
> 直到**后面的0能与前面的0凑到一起形成 00** ，然后转为10使得字符串的值增大
> 然后我们可以以此类推，继续将后边的0往前移动，继续凑00
> 1011110 -> 1001111
> 1001111 -> 1101111
> **直到现在的字符串中只有一个0**，再也没办法使其再增大了

---
## 解题思路

### 贪心+模拟
通过前面的题目分析，其实解法已经很明了了，只要按照我们推解的过程进行模拟即可
1. 遍历字符串，找到每一个0
2. 只要遇到0，则找到其后面的第一个0
3. 将最后的0转为1，当前位置的两位转为10
### 直接构建
其实在分析过程中我们也能发现，其实**操作到最后字符串中只会剩下一个0**
因为但凡还剩下另一个0，那么都有办法将他们凑一一起变成10
也就是说我们可以直接构建一个全1的字符串，然后**找到里边唯一一个0的位置即可**
当然，要是打一开始就没有0，那就返回原字符串即可

所以现在的问题就是如何确定这唯一一个0的位置
> 011**10**10 -> 011**01**10 操作2
> 01**10**110 -> 01**01**110 操作2
> 0**10**1110 -> 0**01**1110 操作2
> **00**11110 -> **10**11110 操作1
> 10111**10** -> 10111**01** 操作2
> 1011**10**1 -> 1011**01**1 操作2
> 101**10**11 -> 101**01**11 操作2
> 10**10**111 -> 10**01**111 操作2
> 1**00**1111 -> 1**10**1111 操作1
> 其实通过观察上面的样例我们可以发现:
> 每次都是首位0与后面的0结合，组成00然后转变为10
> **这不就相当于去掉后面的一个0，然后将首位的0往后移了一位吗**

由此我们需要求的东西也呼之欲出了：
1. 字符串中0的总个数 count
2. 第一个0出现的位置 first
那么在我们最终返回的结果字符串中，这唯一一个0 的位置就应该是在 `dis[first+count-1]`

---
## 对应代码
### 贪心+模拟

```java
/**
 * 模拟+贪心
 * 执行耗时:37 ms,击败了43.64% 的Java用户
 * 内存消耗:44.4 MB,击败了89.09% 的Java用户
 */
class Solution {
	public String maximumBinaryString(String binary) {
		char[] bis = binary.toCharArray();
		int n = bis.length;
		int r = 0;
		for (int i = 0; i < n; i++) {
			// 遇到0则找到其之后的第一个0
			if (bis[i] == '0') {
				while (r <= i || r < n && bis[r] == '1') r++;
				// 通过操作2将0前移，构成"00"，然后通过操作1转成"10"
				if (r < n) {
					bis[r] = '1';
					bis[i] = '1';
					bis[i + 1] = '0';
				}
			}
		}
		return new String(bis);
	}
}
```
#### 复杂度分析 
看起来像是双重循环，但是实际上r是单调递增的
也就是实际上i和r都遍历的一次n
由此时间负责度为O(n)
### 直接构建

```java
/**
 * 直接构建，只要剩下的字符串中有两个0，那么久一定能凑到一起然后被消除
 * 执行耗时:35 ms,击败了50.91% 的Java用户
 * 内存消耗:44.5 MB,击败了85.45% 的Java用户
 */
class Solution {
	public String maximumBinaryString(String binary) {
		char[] bis = binary.toCharArray();
		int n = bis.length;
		// 统计0出现的总次数和第一次出现的位置
		int count = 0;
		int first = -1;
		for (int i = 0; i < n; i++) {
			if (bis[i] == '0') {
				count++;
				if (first == -1) first = i;
			}
		}
		// 没有0则直接返回binary
		if (count == 0) return binary;
		// 将第一个出现的0后移count-1位，而其他0则都变成了1
		for (int i = 0; i < n; i++) {
			if (i == first + count - 1) {
				bis[i] = '0';
			} else {
				bis[i] = '1';
			}
		}
		return new String(bis);
	}
}
```
#### 复杂度分析
整体遍历了两遍字符串，时间复杂度实际上也是为O(n)

---
## 最后

第二个解法其实是第一个解法的拓展，写着写着就会发现，反正都是只会剩一个0，那不如直接找到这个0的位置就好了
唯一没想明白的是，我怎么是35ms

