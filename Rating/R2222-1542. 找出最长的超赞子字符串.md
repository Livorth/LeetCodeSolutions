---
title: R2222-1542. 找出最长的超赞子字符串
time: 2024-05-20
tags:
  - 题解
  - 前缀和
  - 位运算
cssclasses:
  - 力扣题解
rating: "2222"
---
# [1542. 找出最长的超赞子字符串](https://leetcode.cn/problems/find-longest-awesome-substring/)
## 题目详情

给你一个字符串 `s` 。请返回 `s` 中最长的 **超赞子字符串** 的长度。

「超赞子字符串」需满足满足下述两个条件：

- 该字符串是 `s` 的一个非空子字符串
- 进行任意次数的字符交换后，该字符串可以变成一个回文字符串

**示例 1：**

> **输入：** s = "3242415"
> **输出：** 5
> **解释：**"24241" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 "24142"

**示例 2：**

> **输入：** s = "12345678"
> **输出：** 1

**示例 3：**

> **输入：** s = "213123"
> **输出：** 6
> **解释：**"213123" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 "231132"

**示例 4：**

> **输入：** s = "00"
> **输出：** 2

**提示：**
- `1 <= s.length <= 10^5`
- `s` 仅由数字组成

Related Topics
- 位运算
- 哈希表
- 字符串

---
## 题目分析

又是经典的找回文子字符串题目，基本上第一眼就能确认用前缀异或和来解决
在本题中，有几点不同的条件：
- 子字符串可以任意交换位置，只要数量满足回文串的条件即可
- 需要找到最长的回文子字符串

同时我们注意到s.length最大到了10^5，也就是如果使用O(n^2)时间复杂度的解法很可能会超时

---
## 解题思路

还是从最简单的解法开始入手
可以互换回文串有什么特点呢：
- 偶数长度：每个字符出现的次数都是偶数次
- 奇数长度：只有一个字符出现的次数可以为奇数

我们可以一步一步推导：
**1.  最简单的开始:**
直接循环迭代每一个子数组，判断其是否是回文串
但是这样容易超时
所以我们就需要想有没有更快的方式判断s[i,j]是否是回文串
**2. 使用计数前缀和：**
我们在遍历到s[i]的时候同时记录一下，从0开始到i，这段子数组中**每个字符出现的次数**
当我们同时有了pre[0,i]与pre[0,j]时，我们就可以将其两者相减，从而获取到s[i,j]中每个字符出现的次数
**3.使用异或前缀和：**
同时我们有考虑到回文串其实只需要知道每个字符出现的次数是奇数次还是偶数次
那么我们可以直接使用0和1存储其奇偶性即可
正是应为这种奇偶性质的特殊性，所以可以考虑到使用一个int数的二进制来存储
> `pre ^ (1 << s[i]);`

**4. 使用hashMap存储异或值最开始出现的位置：**
前三点其实只解决了如果快速判断s[i,j]是否是回文串的问题
所以我还需要想一个办法能够让我们在**不进行双重循环遍历的同时快速获取到相聚最远的i与j**
当我们在遍历j的时候，我们肯定是想着i要越远越好
所以在**异或前缀和相同的时候，肯定是选越远的越好**（因为异或前缀和只是存奇偶情况，所以重复概率极大）
于是，可以使用一个HashMap存储每一个异或前缀和第一次出现的位置
- 对于偶数长度：`pre[j] ⊕ pre[i] = 0`
	- 这样则说明在s[i,j]里每个数字的出现次数都得是偶数
- 对于奇数长度：`pre[j] ⊕ pre[i] = 2^T`，其中T为任意字符值
	- 2^T是只有一个 111 的二进制数，也就是说只有一个数出现次数为奇数

---
## 对应代码

```java
/**
 * 前缀异或和，使用HashMap存储前缀异或值以及其第一次出现的位置
 * 执行耗时:108 ms,击败了45.24% 的Java用户
 * 内存消耗:44.4 MB,击败了33.33% 的Java用户
 */
class Solution {
	public int longestAwesome(String s) {
		// key:前缀异或值, value:其第一次出现的位置
		HashMap<Integer, Integer> map = new HashMap<>();
		map.put(0, -1);
		int res = 0;
		// 记录前缀异或和的值
		int pre = 0;
		for (int i = 0; i < s.length(); i++) {
			pre = pre ^ (1 << s.charAt(i) - '0');
			// 奇数部分
			for (int j = 0; j < 10; j++) {
				if (map.containsKey(pre ^ (1 << j))) {
					res = Math.max(res, i - map.get(pre ^ (1 << j)));
				}
			}
			// 偶数部分
			if (map.containsKey(pre)) {
				res = Math.max(res, i - map.get(pre));
			} else {
				map.put(pre, i);
			}
		}
		return res;
	}
}
```
### 复杂度分析

时间复杂度：O(n * T)，其中T为字符串s中字符的种类
空间复杂度：理论最大O(2^T)

---
## 最后

回文题一眼前缀异或和，是一个难点
而本题的另一个难点则是如何快速找到**最长**

