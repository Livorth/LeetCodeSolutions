---
title: R1748-2134. 最少交换次数来组合所有的 1 II
time: 2024-02-02
tags:
  - 题解
  - 滑动窗口
  - 定长滑动窗口
cssclasses:
  - 力扣题解
rating: "1748"
---
# [2134. 最少交换次数来组合所有的 1 II](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/)
## 题目详情

**交换** 定义为选中一个数组中的两个 **互不相同** 的位置并交换二者的值。

**环形** 数组是一个数组，可以认为 **第一个** 元素和 **最后一个** 元素 **相邻** 。

给你一个 **二进制环形** 数组 `nums` ，返回在 **任意位置** 将数组中的所有 `1` 聚集在一起需要的最少交换次数。

**示例 1：**

> **输入：** `nums = [0,1,0,1,1,0,0]`
> **输出：** 1
> **解释：** 这里列出一些能够将所有 1 聚集在一起的方案：
> `[0,_0_,_1_,1,1,0,0]` 交换 1 次。
> `[0,1,_1_,1,_0_,0,0]` 交换 1 次。
> `[1,1,0,0,0,0,1]` 交换 2 次（利用数组的环形特性）。
> 无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。
> 因此，需要的最少交换次数为 1 。

**示例 2：**

> **输入：** `nums = [0,1,1,1,0,0,1,1,0]`
> **输出：** 2
> **解释：** 这里列出一些能够将所有 1 聚集在一起的方案：
> `[1,1,1,0,0,0,0,1,1]` 交换 2 次（利用数组的环形特性）。
> `[1,1,1,1,1,0,0,0,0]` 交换 2 次。
> 无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。
> 因此，需要的最少交换次数为 2 。

**示例 3：**

> **输入：** `nums = [1,1,0,0,1]`
> **输出：** 0
> **解释：** 得益于数组的环形特性，所有的 1 已经聚集在一起。
> 因此，需要的最少交换次数为 0 。

**提示：**

- `1 <= nums.length <= 10^5`
- `nums[i]` 为 `0` 或者 `1`

Related Topics
- 数组
- 滑动窗口

---
## 题目分析

题目的目的就是将数组中的1全部聚集到一起，例如在长度为n的数组中有k个1，那就需要通过交换将其他位置的1换过来，然后成功**一个长度为k并且其中元素全部为1的连续子数组**
同时需要注意的一点就是，题目给的数组为环形数组，也就是相当于**首尾相连**

---
## 解题思路

由于我们需要构造出长度为k的子数组，那么自然而然能想到使用定长的滑动窗口来实现
目的是使滑动窗口中所有的元素全部为1，那么**窗口中缺几个1，那就需要补几次**，最终的结果就是**补的最少的次数**
于是我们可以遍历每一个，获取到每一个窗口中1的个数，当1的个数最多，那么需要交换的次数也就是最少的

---
## 对应代码

```java
/**
 * 定长滑动窗口
 * 执行耗时:8 ms,击败了60.76% 的Java用户
 * 内存消耗:57.5 MB,击败了44.94% 的Java用户
 */
class Solution {
	public int minSwaps(int[] nums) {
		int n = nums.length;
		// 确认滑动窗口长度
		int j = 0;
		for (int i = 0; i < n; i++) {
			if (nums[i] == 1) j++;
		}
		// 初始化第一个滑动窗口
		int count = 0;
		for (int i = 0; i < j; i++) {
			if (nums[i] == 1) count++;
		}
		int res = count;
		// 遍历每一个窗口
		for (int i = 0; i < n; i++) {
			if (nums[i] == 1) count--;
			if (nums[(i + j) % n] == 1) count++;
			res = Math.max(res, count);
		}
		return j - res;
	}
}
```
### 复杂度分析

一共只进行了两次遍历
所以时间复杂度为O(n)

---
## 最后

简单的滑动窗口题

