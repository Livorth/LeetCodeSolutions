---
title: R2232-1766. 互质树
time: 2024-04-11
tags:
  - 题解
  - dfs
  - 回溯
  - 预处理
  - 树
cssclasses:
  - 力扣题解
rating: "2232"
---
# [1766. 互质树](https://leetcode.cn/problems/tree-of-coprimes/)
## 题目详情

给你一个 `n` 个节点的树（也就是一个无环连通无向图），节点编号从 `0` 到 `n - 1` ，且恰好有 `n - 1` 条边，每个节点有一个值。树的 **根节点** 为 0 号点。

给你一个整数数组 `nums` 和一个二维数组 `edges` 来表示这棵树。`nums[i]` 表示第 `i` 个点的值，`edges[j] = [uj, vj]` 表示节点 `uj` 和节点 `vj` 在树中有一条边。

当 `gcd(x, y) == 1` ，我们称两个数 `x` 和 `y` 是 **互质的** ，其中 `gcd(x, y)` 是 `x` 和 `y` 的 **最大公约数** 。

从节点 `i` 到 **根** 最短路径上的点都是节点 `i` 的祖先节点。一个节点 **不是** 它自己的祖先节点。

请你返回一个大小为 `n` 的数组 `ans` ，其中 `ans[i]`是离节点 `i` 最近的祖先节点且满足 `nums[i]` 和 `nums[ans[i]]` 是 **互质的** ，如果不存在这样的祖先节点，`ans[i]` 为 `-1` 。

**示例 1：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram.png)**

**输入：** nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
**输出：**[-1,0,0,1]
**解释：** 上图中，每个节点的值在括号中表示。
- 节点 0 没有互质祖先。
- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。
- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。
- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram1.png)

**输入：** nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
**输出：**[-1,0,-1,0,0,0,-1]

**提示：**
- `nums.length == n`
- `1 <= nums[i] <= 50`
- `1 <= n <= 10^5`
- `edges.length == n - 1`
- `edges[j].length == 2`
- `0 <= uj, vj < n`
- `uj != vj`

Related Topics
- 树
- 深度优先搜索
- 广度优先搜索
- 数组
- 数学
- 数论

---
## 题目分析

题目给出了一个多叉树，每个节点都有着对应的值，这些值的**范围为 `1 <= nums[i] <= 50`**
而我们要找的是每个节点**离他最近的互质祖宗节点**
1. 互质：最大公因数为1 
2. 祖宗节点：一定在当前节点之上
3. 最近：如果爸爸与爷爷都和他互质，那优先区爸爸
到目前为止条理非常清楚
题目意图理解了，那接下来就要梳理下解题思路

---
## 解题思路

如果可以的话，其实从下往上遍历是最方便的，但很遗憾的是并不能这么做
如果是从上往下遍历的话，那么肯定要想个办法将沿途的祖宗们存起来

**第一种办法：**
直接将沿途的祖宗全部**用单条链表**存起来
1. 实现dfs，其中传递一个list存储当前节点的祖宗们
2. 从list**尾部**开始遍历起，判断当前节点与当前祖宗是否互质，互质的则为结果
但是当我们分析一下时间复杂度可以发现其中的问题
- 如果这棵树长的像链表的时候，那么不是每个节点都会进到list中？
- 这样的话时间复杂度不就为O(n^2)了？
**由此我们需要像一种能快速找到最近互质祖宗的办法**

**第二种办法：**
我们通过前面的题目分析可以发现nums种值的**范围为 `1 <= nums[i] <= 50`**
那么是不是意味着我们可以按照值来进行分组，将相同值的祖宗放到同组里
**这样就从需要遍历整条list变为只需要遍历长为50的数组list[]**
这样我们的思路就变为：
1. 初始化数组：`list[val][num,depth]`，val表示节点值，num表示节点位置，depth表示这个节点的对应深度。`res[i]`，则表示当前节点的结果节点
2. 构建邻接表
4. 实现dfs
	1. 获取当前节点的值val
	2. 枚举1到50，判断是否互质，如果互质，满足一下条件则更新`nums[i]`
		- `nums[i]`为空
		- `num[i]`的深度小于当前互质到的节祖宗节点的深度
	3. 将当期节点放到list中去，并遍历自己的儿子节点
	4. 回溯
5. 实现gcd方法

其实核心点在于不同值的祖宗节点位置与深度的存储
只要弄明白这个就好做了

当然，这个解法还能优化
我们在上述解法里还在每次的dfs中都需要枚举1到50，来算是否互质嘛
其实我们可以直接进行预处理，**先一步求出1到50里每一个值与那些值互质**
这样我们就值需要**枚举到那些互质的值即可**

---
## 对应代码

```java
/**
 * 预处理 + dfs
 * 执行耗时:103 ms,击败了51.35% 的Java用户
 * 内存消耗:98.4 MB,击败了37.84% 的Java用户
 */
class Solution {

	List<Integer>[] map;
	// 存储与i互质的list集合
	List<Integer>[] gcd = new List[51];
	// 值为i的最近祖先的编号，没有则为-1
	int[] pre = new int[51];
	// 每个节点对应的深度
	int[] dep;
	int[] res;

	public int[] getCoprimes(int[] nums, int[][] edges) {
		int n = nums.length;
		map = new List[n];
		res = new int[n];
		dep = new int[n];
		Arrays.setAll(map, i -> new ArrayList<>());
		Arrays.setAll(gcd, i -> new ArrayList<>());
		Arrays.fill(res, -1);
		Arrays.fill(pre, -1);

		// 邻接表
		for (int[] edge : edges) {
			map[edge[0]].add(edge[1]);
			map[edge[1]].add(edge[0]);
		}
		// 预处理出50位里边每个数的互质数
		for (int i = 1; i <= 50; i++) {
			for (int j = 1; j <= 50; j++) {
				if (gcd(i, j) == 1) gcd[i].add(j);
			}
		}

		dfs(nums, 0, -1);
		return res;
	}

	private void dfs(int[] nums, int x, int pa) {
		int val = nums[x];
		// 枚举所有可以与val互质的值
		for (int i : gcd[val]) {
			// 还未存在过值为i的祖宗
			if (pre[i] == -1) continue;
			// 如果还没找到最近的点，就先随便找个祖宗用着
			// 如果找到现在用的祖宗深度很小，则需要换深度更大的祖宗，更亲一点
			if (res[x] == -1 || dep[res[x]] < dep[pre[i]]) {
				res[x] = pre[i];
			}
		}
		// 暂存一下，让自己也进pre
		int tmp = pre[val];
		pre[val] = x;

		// 遍历x的儿子
		for (int i : map[x]) {
			if (i == pa) continue;
			dep[i] = dep[x] + 1;
			dfs(nums, i, x);
		}
		// 回溯
		pre[val] = tmp;
	}

	private int gcd(int a, int b) {
		if (a < b) {
			int t = a;
			a = b;
			b = t;
		}
		return b == 0 ? a : gcd(b, a % b);
	}
}
```
### 复杂度分析

邻接表构建的时间复杂度为O(n)
预处理gcd的时间复杂度为O(50 * 50)
而在dfs中，主要的循环还是在枚举所有可以与val互质的值，也就是时间复杂度为O(nU)，U=max(nums)=50
那么最终的**时间复杂度为O(n)**
空间复杂度同理，为O(n+U)

---
## 最后

只要能想出暴力解，其实里最终的优化方案也不远了
主要还是数值范围这个提示比较关键

