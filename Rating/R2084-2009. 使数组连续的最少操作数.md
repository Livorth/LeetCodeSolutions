---
title: R2084-2009. 使数组连续的最少操作数
time: 2024-04-08
tags:
  - 题解
  - 滑动窗口
  - 变长滑动窗口
  - 数组
cssclasses:
  - 力扣题解
rating: "2084"
---
# [2009. 使数组连续的最少操作数](https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/)
## 题目详情

给你一个整数数组 `nums` 。每一次操作中，你可以将 `nums` 中 **任意** 一个元素替换成 **任意** 整数。

如果 `nums` 满足以下条件，那么它是 **连续的** ：

- `nums` 中所有元素都是 **互不相同** 的。
- `nums` 中 **最大** 元素与 **最小** 元素的差等于 `nums.length - 1` 。

比方说，`nums = [4, 2, 5, 3]` 是 **连续的** ，但是 `nums = [1, 2, 3, 5, 6]` **不是连续的** 。

请你返回使 `nums` **连续** 的 **最少** 操作次数。

**示例 1：**

> **输入：** nums = [4,2,5,3]
> **输出：** 0
> **解释：** nums 已经是连续的了。

**示例 2：**

> **输入：** nums = [1,2,3,5,6]
> **输出：** 1
> **解释：** 一个可能的解是将最后一个元素变为 4 。
> 结果数组为 [1,2,3,5,4] ，是连续数组。

**示例 3：**

> **输入：** nums = [1,10,100,1000]
> **输出：** 3
> **解释：** 一个可能的解是：
>
> - 将第二个元素变为 2 。
> - 将第三个元素变为 3 。
> - 将第四个元素变为 4 。
>   结果数组为 [1,2,3,4] ，是连续数组。

**提示：**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`

Related Topics
- 数组
- 哈希表
- 二分查找
- 滑动窗口

---
## 题目分析

题目的意思很好理解，就是将不连续的数组转换为连续的数组
主要是注意以下几点：
- 数组不一定是从1开始的
- 数组中可能存在重复的数
- 连续与否和数组中数字位置没有关系

---
## 解题思路

我们可以从连续的这点开始做文章
因为这部分的数组完全就是固定了，**长度固定且连续**
唯一不知道的就是**在哪一位开始或者说在哪一位结束**
这看起来很像一个什么东西，没错就是**定长的滑动窗口**

我最开始的想法是用一个计数排序，用一个辅助数组存一下每个数的出现情况
然后拿着这个定长的滑动窗口放到上面滑
滑动窗口里**缺了的数就是需要操作的次数**，我们只要找到缺数最少的滑动窗口就好了
然后我就发现了`1 <= nums[i] <= 10^9`，显然这样计数不了一点，内存会爆

由此就只能用不定长的滑动窗口了，和上面的思路其实还是差不多
- 不用计数排序了，**直接用快排在原数组的基础上排序即可**
- 需要去重
- 不定长的滑动窗口，左右边界对应值之差不能大于`nums.length-1`，也就是满足”连续“这一条件
这个时候滑动窗口里有的值，依旧还是不需要操作的数，要将这个窗口里的数扩充到满足题目的条件则需要再操作 `nums.length - 滑动窗口中数字的个数`次
所以我们还是只需要**找到什么时候滑动窗口中的数字最多即可**

顺带一提还有一种二分查找的方法，同样也是确定一边的边界，然后在通过二分查找确定另外一边的边界，不过感觉不过滑动窗口简洁就不写了

---
## 对应代码

```java
/**
 * 执行耗时:38 ms,击败了100.00% 的Java用户
 * 内存消耗:55.3 MB,击败了76.09% 的Java用户
 */
class Solution {
	public int minOperations(int[] nums) {
		Arrays.sort(nums);
		int len = 1;
		// 去重
		for (int i = 1; i < nums.length; i++) {
			if (nums[i] != nums[i - 1]) {
				nums[len++] = nums[i];
			}
		}

		int ans = 0;
		int left = 0;
		// 枚举右边界
		for (int right = 0; right < len; right++) {
			// 左边界收缩，滑动窗口的值以右边界为准，差等于nums.length-1
			while (nums[left] < nums[right] - nums.length + 1) {
				left++;
			}
			ans = Math.max(ans, right - left + 1);
		}
		return nums.length - ans;
	}
}
```

### 复杂度分析
**时间复杂度**：最主要的耗时在排序上，O(nlogn)，还有就是两次遍历数组，O(n)，总计就是O(nlogn)
**空间复杂度**：没有使用辅助空间，就是在原数组上进行的修改，O(1)

---
## 最后

感觉没那么难啊，是因为我写了一段时间的滑动窗口然后一眼就看出来了吗

