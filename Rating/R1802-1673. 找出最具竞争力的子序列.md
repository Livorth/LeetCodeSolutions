---
title: R1802-1673. 找出最具竞争力的子序列
time: 2024-05-24
tags:
  - 题解
cssclasses:
  - 力扣题解
rating: "1802"
---
# [1673. 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/)
## 题目详情

给你一个整数数组 `nums` 和一个正整数 `k` ，返回长度为 `k` 且最具 **竞争力** 的 `nums` 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 `a` 和子序列 `b` 第一个不相同的位置上，如果 `a` 中的数字小于 `b` 中对应的数字，那么我们称子序列 `a` 比子序列 `b`（相同长度下）更具 **竞争力** 。 例如，`[1,3,4]` 比 `[1,3,5]` 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， `4` 小于 `5` 。

**示例 1：**

> **输入：** nums = [3,5,2,6], k = 2
> **输出：**[2,6]
> **解释：** 在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。

**示例 2：**

> **输入：** nums = [2,4,3,3,5,4,9,6], k = 4
> **输出：**[2,3,3,4]

**提示：**
- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 10^9`
- `1 <= k <= nums.length`

Related Topics
- 栈
- 贪心
- 数组
- 单调栈
---
## 题目分析

在本题中所谓的最具有竞争力其实就是字典序最小
所以我们需要找到就是**长度为K的字典序最小子数组**

---
## 解题思路

首先要明确的时候，我们是找的子数组，每个元素的顺序是不能变的
不然直接一个sort解决问题

找字典序最小的子数组，首先能想到的就是使用**单调栈**

定义一个长度为k的单调栈
- 栈顶元素比当前元素更大，则一直出栈
- 栈中未满则入栈

但是需要注意的是，当数组中没遍历到的元素和栈中的元素加一起不足k的时候就不要出栈了，不然最后子数组长度不足k

---
## 对应代码

```java
/**
 * 单调栈
 * 执行耗时:7 ms,击败了94.69% 的Java用户
 * 内存消耗:59.4 MB,击败了53.98% 的Java用户
 */
class Solution {
	public int[] mostCompetitive(int[] nums, int k) {
		int n = nums.length;
		int[] stack = new int[k];
		int top = 0;
		for (int i = 0; i < nums.length; i++) {
			while (top > 0 && nums[i] < stack[top - 1] && n - i + top > k) {
				top--;
			}
			if (top < k) {
				stack[top++] = nums[i];
			}
		}
		return stack;
	}
}
```

### 复杂度分析

时间复杂度：O(n)，每个元素只有一次入栈和出栈的机会，虽然是双重循环但是实际上也是O(n)
空间复杂度：O(n)，定义了长度为K的辅助数组

---
## 最后

模板题？

