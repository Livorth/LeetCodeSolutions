---
title: R1946-1793. 好子数组的最大分数
time: 2024-01-08
tags:
  - 题解
  - 双指针
cssclasses:
  - 力扣题解
rating: "1946"
---
# [1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/)
## 题目详情

给你一个整数数组 `nums` **（下标从 0 开始）** 和一个整数 `k` 。

一个子数组 `(i, j)` 的 **分数** 定义为 `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)` 。一个 **好** 子数组的两个端点下标需要满足 `i <= k <= j` 。

请你返回 **好** 子数组的最大可能 **分数** 。

**示例 1：**

> **输入：** `nums = [1,4,3,7,4,5], k = 3`
> **输出：** 15
> **解释：** 最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。

**示例 2：**

> **输入：** `nums = [5,5,4,5,4,1,1,1], k = 0`
> **输出：** 20
> **解释：** 最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。

**提示：**
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 2 * 104`
- `0 <= k < nums.length`

Related Topics
- 栈
- 数组
- 双指针
- 二分查找
- 单调栈
---
## 题目分析

所谓好的子数组，就是子数组**开始与结束的下标分别在k的两侧**，即`i <= k <= j`
所以我们在计算子数组的时候可以采用双指针的方式，**从k开始往两边开始遍历，两个指针分别指向子数组开始和结束的位置**。

其次还有一点就是，**分数**的组成
- `min(nums[i], nums[i+1], ..., nums[j])`，也就是子数组中最小的值
- `j - i + 1`，也就是子数组的长度

---
## 解题思路

当理清楚上面两点之后，思路也基本明了了：
- 通过双指针的方式往两边扩展确定每次的子数组范围
- 定义flag为当前子数组中最小的值
我们双指针在往两边遍历的时候，遍历到存在比flag更小的元素的时候停止
这样就能保证f**lag为当前子数组最小的元素**，**同时子数组的长度还能最大**

在计算完当前flag之后需要**根据两边的元素进行更新**
- 如果两边中存在一边到头了，则直接选另一侧的元素作为新的flag即可
- 如果两边都还有元素，则选择其中较大的一个
	- **为什么不是更小的那个？**
	- 因为`nums[l], nums[r]`都比flag要小，如果直接选更小的那个，就会漏掉中间大小的这个flag没算

---
## 对应代码

```java
/**  
 * 双指针  
 * 执行耗时:2 ms,击败了100.00% 的Java用户  
 * 内存消耗:56.5 MB,击败了14.47% 的Java用户  
 */  
class Solution {  
    public int maximumScore(int[] nums, int k) {  
        int res = 0;  
        int r = k, l = k;  
        int flag = nums[k];  
        while (true) {  
            // 求出flag为最小值的范围，并更新结果  
            while (r < nums.length && nums[r] >= flag) r++;  
            while (l >= 0 && nums[l] >= flag) l--;  
            res = Math.max(res, (r - l - 1) * flag);  
  
            if (l < 0 && r >= nums.length) break;  
            // 更新flag  
            if (l >= 0 && r < nums.length) {  
                // 选较大的是因为nums[l], nums[r]都比flag要小，如果直接选更小的那个，就会漏掉中间一个没算  
                flag = Math.max(nums[l], nums[r]);  
            } else if (l < 0) {  
                flag = nums[r];  
            } else {  
                flag = nums[l];  
            }  
        }  
        return res;  
    }  
}
```
### 复杂度分析
整体循环只对nums数组进行了一次的遍历
所以时间复杂度为O(n)
空间复杂度方面，并没有使用辅助数组，所以空间复杂度O(1)

---
## 最后

R1946，比想的要简单不少
思路很清晰，没有弯弯绕绕

